
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Convective Outlook Platform</title>
  <script defer src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.development.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.development.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.22.5/babel.min.js"></script>
  <script defer src="https://cdn.tailwindcss.com"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/react-router-dom@5.2.0/umd/react-router-dom.min.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.2/firebase-compat.js"></script>
  <script defer src="https://api.mapbox.com/mapbox-gl-js/v2.13.0/mapbox-gl.js"></script>
  <script defer src="https://unpkg.com/@mapbox/mapbox-gl-draw@1.4.2/dist/mapbox-gl-draw.js"></script>
  <script defer src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script defer src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script defer src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script defer src="https://unpkg.com/@tmcw/togeojson@5.8.1/dist/togeojson.umd.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" />
  <link rel="stylesheet" href="https://unpkg.com/@mapbox/mapbox-gl-draw@1.4.2/dist/mapbox-gl-draw.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
</head>
<body>
  <div id="root" className="min-h-screen bg-gray-50"></div>

  <script type="text/babel">
    if (!window.ReactRouterDOM) {
      console.error('ReactRouterDOM not loaded. Check CDN link or network.');
      throw new Error('ReactRouterDOM is undefined');
    }

    const { useState, useEffect, useRef } = React;
    const { BrowserRouter, Switch, Route, Link, useHistory, Redirect } = window.ReactRouterDOM;
    const { createRoot } = ReactDOM;

    const firebaseConfig = { apiKey: "AIzaSyDCCldk6q6R10O_hrEocjsGybQkmHEF2g4", authDomain: "convective-outlook-5dfbc.firebaseapp.com", projectId: "convective-outlook-5dfbc", storageBucket: "convective-outlook-5dfbc.firebasestorage.app", messagingSenderId: "452758486520", appId: "1:452758486520:web:9b0670240af6a4396caa0d" };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    const UK_BBOX = [-11, 49, 2, 61];
    const STRIKE_RADIUS_KM = 40;
    const RISK_WEIGHTS = {
      'low risk': 1.0,
      'slight risk': 1.5,
      'enhanced risk': 2.0,
      'moderate risk': 2.5,
      'high risk': 3.0,
      'severe risk': 3.5
    };
    const PENALTY_MULTIPLIERS = {
      'low risk': 1.0,
      'slight risk': 1.2,
      'enhanced risk': 1.5,
      'moderate risk': 1.8,
      'high risk': 2.0,
      'severe risk': 2.2
    };
    const RISK_COLORS = {
      'low risk': '#66c2a4',
      'slight risk': '#fff200',
      'enhanced risk': '#ff7f27',
      'moderate risk': '#ec1c24',
      'high risk': '#b83dba',
      'severe risk': '#000000'
    };
    const RISK_ORDER = ['low risk', 'slight risk', 'enhanced risk', 'moderate risk', 'high risk', 'severe risk'];

    const waitForLeaflet = (callback) => {
      if (window.L) {
        callback();
      } else {
        const checkInterval = setInterval(() => {
          if (window.L) {
            clearInterval(checkInterval);
            callback();
          }
        }, 100);
        setTimeout(() => {
          if (!window.L) {
            console.error('Leaflet failed to load after timeout');
            clearInterval(checkInterval);
          }
        }, 5000);
      }
    };
    const waitForMapbox = (callback) => {
      if (window.mapboxgl && window.MapboxDraw) {
        callback();
      } else {
        const checkInterval = setInterval(() => {
          if (window.mapboxgl && window.MapboxDraw) {
            clearInterval(checkInterval);
            callback();
          }
        }, 100);
        setTimeout(() => {
          if (!window.mapboxgl || !window.MapboxDraw) {
            console.error('Mapbox GL JS or Mapbox Draw failed to load after timeout');
            clearInterval(checkInterval);
          }
        }, 5000);
      }
    };
    const downloadKML = (polygons, filename) => {
      if (!polygons || polygons.length === 0) {
        alert('No polygons to export.');
        return;
      }

      const kmlHeader = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>${filename}</name>
    <Style id="lowRisk">
      <LineStyle><color>ff66c2a4</color><width>2</width></LineStyle>
      <PolyStyle><color>8066c2a4</color></PolyStyle>
    </Style>
    <Style id="slightRisk">
      <LineStyle><color>ff00f2ff</color><width>2</width></LineStyle>
      <PolyStyle><color>8000f2ff</color></PolyStyle>
    </Style>
    <Style id="enhancedRisk">
      <LineStyle><color>ff277fff</color><width>2</width></LineStyle>
      <PolyStyle><color>80277fff</color></PolyStyle>
    </Style>
    <Style id="moderateRisk">
      <LineStyle><color>ff241cec</color><width>2</width></LineStyle>
      <PolyStyle><color>80241cec</color></PolyStyle>
    </Style>
    <Style id="highRisk">
      <LineStyle><color>ffba3db8</color><width>2</width></LineStyle>
      <PolyStyle><color>80ba3db8</color></PolyStyle>
    </Style>
    <Style id="severeRisk">
      <LineStyle><color>ff800080</color><width>2</width></LineStyle>
      <PolyStyle><fill>0</fill></PolyStyle>
    </Style>`;

      const kmlFooter = `
  </Document>
</kml>`;

      const kmlPolygons = polygons.map((polygon, index) => {
        const coords = polygon.geometry.coordinates[0].map(coord => `${coord[0]},${coord[1]},0`).join(' ');
        const riskLevel = polygon.properties.Name.toLowerCase().replace(' ', '');
        return `
    <Placemark>
      <name>Polygon ${index + 1} - ${polygon.properties.Name}</name>
      <styleUrl>#${riskLevel}</styleUrl>
      <Polygon>
        <outerBoundaryIs>
          <LinearRing>
            <coordinates>${coords}</coordinates>
          </LinearRing>
        </outerBoundaryIs>
      </Polygon>
    </Placemark>`;
      }).join('');

      const kmlContent = `${kmlHeader}${kmlPolygons}${kmlFooter}`;
      const blob = new Blob([kmlContent], { type: 'application/vnd.google-earth.kml+xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${filename}.kml`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    };

    const importKML = (file, setDrawnItems, drawRef, mapRef, setDataError) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const kmlText = e.target.result;
          const kmlDoc = new DOMParser().parseFromString(kmlText, 'text/xml');
          const geojson = window.toGeoJSON.kml(kmlDoc);

          if (!geojson.features || geojson.features.length === 0) {
            setDataError('No valid polygons found in KML file.');
            return;
          }

          const newFeatures = geojson.features
            .filter(f => f.geometry.type === 'Polygon')
            .map((f, index) => {
              const nameMatch = f.properties.name?.match(/Polygon \d+ - (.+)/i);
              const riskLevel = nameMatch ? nameMatch[1].toLowerCase() : 'low risk';
              const validRisk = RISK_ORDER.includes(riskLevel) ? riskLevel : 'low risk';
              return {
                ...f,
                id: `imported-${index}-${Date.now()}`,
                properties: {
                  Name: validRisk,
                  color: RISK_COLORS[validRisk],
                  severeConditions: validRisk === 'severe risk' ? {
                    rainfall: false,
                    hail: false,
                    tornado: false,
                    gusts: false
                  } : {}
                }
              };
            });

          drawRef.current.deleteAll();
          newFeatures.forEach(feature => drawRef.current.add(feature));
          setDrawnItems(newFeatures);

          if (mapRef.current.getSource('drawnFeatures')) {
            mapRef.current.getSource('drawnFeatures').setData({
              type: 'FeatureCollection',
              features: newFeatures
            });
          }
          setDataError(null);
        } catch (err) {
          console.error('Error importing KML:', err);
          setDataError('Failed to import KML file.');
        }
      };
      reader.onerror = () => setDataError('Error reading KML file.');
      reader.readAsText(file);
    };

    const fetchLightningData = async (date, setError) => {
      console.log('Fetching lightning data for date:', date);
      if (!date) {
        console.warn('No date provided for lightning data fetch');
        return [];
      }
      try {
        const startTime = new Date(`${date}T06:00:00+01:00`);
        const endTime = new Date(startTime);
        endTime.setDate(startTime.getDate() + 1);
        endTime.setHours(5, 59, 59, 999);
        console.log('Lightning data period:', startTime, 'to', endTime);

        const githubUrl = 'https://raw.githubusercontent.com/Handry6/lightning_data/refs/heads/main/lightning_data.json';
        const metOfficeBaseUrl = 'https://data.consumer-digital.api.metoffice.gov.uk/v1/lightning';
        let allStrikes = [];

        const fetchWithTimeout = async (url, timeout = 5000) => {
          const controller = new AbortController();
          const id = setTimeout(() => controller.abort(), timeout);
          try {
            const response = await fetch(url, { signal: controller.signal });
            clearTimeout(id);
            return response;
          } catch (err) {
            clearTimeout(id);
            throw err;
          }
        };

        let githubStrikes = [];
        try {
          console.log('Fetching from GitHub:', githubUrl);
          const githubResponse = await fetchWithTimeout(githubUrl);
          if (!githubResponse.ok) {
            throw new Error(`GitHub fetch failed: ${githubResponse.status}`);
          }
          const githubData = await githubResponse.json();
          if (!githubData?.lightning_strikes) {
            throw new Error('Invalid GitHub data format');
          }
          githubStrikes = githubData.lightning_strikes
            .map(s => ({
              time: new Date(s.strike_time),
              coordinates: s.coordinates
            }))
            .filter(s => s.time >= startTime && s.time <= endTime);
          console.log('GitHub strikes fetched:', githubStrikes.length);
        } catch (err) {
          console.warn('GitHub data fetch failed:', err);
          setError(prev => prev || 'Unable to fetch GitHub lightning data.');
        }

        let baseStrikes = [];
        let chunkStrikes = [];
        try {
          console.log('Fetching from Met Office:', metOfficeBaseUrl);
          const mainResponse = await fetchWithTimeout(metOfficeBaseUrl);
          if (!mainResponse.ok) {
            throw new Error(`Met Office base fetch failed: ${mainResponse.status}`);
          }
          const mainData = await mainResponse.json();
          if (!mainData?.lightning_strikes) {
            throw new Error('Invalid Met Office data format');
          }
          baseStrikes = mainData.lightning_strikes
            .map(s => ({
              time: new Date(s.strike_time),
              coordinates: s.coordinates
            }))
            .filter(s => s.time >= startTime && s.time <= endTime);
          console.log('Met Office base strikes fetched:', baseStrikes.length);

          const chunkUrls = mainData?.chunks?.map(chunk =>
            `${metOfficeBaseUrl}?last-minutes=1&chunk=${chunk.chunk}`
          ) || [];
          console.log('Chunk URLs:', chunkUrls);
          const chunkResponses = await Promise.all(
            chunkUrls.map(async url => {
              try {
                console.log('Fetching chunk:', url);
                const res = await fetchWithTimeout(url);
                if (!res.ok) {
                  console.warn(`Met Office chunk fetch failed for ${url}: ${res.status}`);
                  return null;
                }
                const data = await res.json();
                return data;
              } catch (err) {
                console.warn(`Met Office chunk fetch error for ${url}:`, err);
                return null;
              }
            })
          );
          chunkStrikes = chunkResponses.flatMap(response =>
            response?.lightning_strikes?.map(s => ({
              time: new Date(s.strike_time),
              coordinates: s.coordinates
            }))?.filter(s => s.time >= startTime && s.time <= endTime) || []
          );
          console.log('Met Office chunk strikes fetched:', chunkStrikes.length);
        } catch (err) {
          console.warn('Met Office API failed, using GitHub data only:', err);
          setError(prev => prev || 'Unable to fetch Met Office lightning data. Using GitHub data.');
        }

        allStrikes = [...githubStrikes, ...baseStrikes, ...chunkStrikes];
        console.log('Total strikes before filtering:', allStrikes.length);
        const seen = new Map();
        const filteredStrikes = allStrikes.filter(s => {
          if (!s.coordinates || s.coordinates.length !== 2 || isNaN(s.coordinates[0]) || isNaN(s.coordinates[1])) {
            console.warn('Invalid strike coordinates:', s);
            return false;
          }
          const key = `${s.coordinates.join(',')}_${s.time}`;
          if (!seen.has(key)) {
            seen.set(key, true);
            return true;
          }
          return false;
        }).filter(s => {
          const [lon, lat] = s.coordinates;
          return lon >= UK_BBOX[0] && lon <= UK_BBOX[2] && lat >= UK_BBOX[1] && lat <= UK_BBOX[3];
        });
        console.log('Filtered strikes:', filteredStrikes.length);

        if (filteredStrikes.length === 0) {
          setError(prev => prev || 'No lightning data available for the selected date.');
        }

        return filteredStrikes;
      } catch (err) {
        console.error('Error fetching lightning data:', err);
        setError('Failed to fetch lightning data.');
        return [];
      }
    };
   const calculateScore = async (polygons, date, outlookId) => {
  try {
    console.log(`Calculating score for outlook ${outlookId} on date ${date}`);

    // Fetch lightning strikes for the given date
    const strikes = await fetchLightningData(date, (error) => console.error('Score calculation error:', error));
    if (!strikes || strikes.length === 0) {
      console.warn(`No lightning strikes available for ${date}`);
      return 1; // Minimum score to avoid 0
    }

    // Fetch severe weather reports for the given date
    const startTime = new Date(`${date}T06:00:00+01:00`);
    const endTime = new Date(startTime);
    endTime.setDate(startTime.getDate() + 1);
    endTime.setHours(5, 59, 59, 999);
    const severeReportsSnapshot = await db.collection('severe_reports')
      .where('date', '==', date)
      .get();
    const severeReports = severeReportsSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      observedAt: doc.data().observedAt ? new Date(doc.data().observedAt) : null
    })).filter(report => {
      if (!report.observedAt) return true; // Include reports without observedAt for backward compatibility
      return report.observedAt >= startTime && report.observedAt <= endTime;
    });

    // Generate sample points for non-strike areas
    const generateSamplePoints = (polygons, numPoints = 30) => {
      const samplePoints = [];
      const totalPolys = polygons.reduce((sum, p) => {
        const geom = turf.polygon(p.geometry.coordinates);
        return sum + (geom.geometry.type === 'Polygon' ? 1 : geom.geometry.coordinates.length);
      }, 0);
      const pointsPerPoly = Math.max(1, Math.floor(numPoints / totalPolys));
      polygons.forEach(polygon => {
        const geom = turf.polygon(polygon.geometry.coordinates);
        const bbox = turf.bbox(geom);
        let pointsAdded = 0;
        let attempts = 0;
        const maxAttempts = pointsPerPoly * 5;
        while (pointsAdded < pointsPerPoly && attempts < maxAttempts) {
          const randomPoint = turf.randomPoint(1, { bbox }).features[0];
          if (turf.booleanPointInPolygon(randomPoint, geom)) {
            samplePoints.push(randomPoint);
            pointsAdded++;
          }
          attempts++;
        }
      });
      return samplePoints;
    };

    // Calculate strike density
    const calculateStrikeDensity = (strikes, point, radiusKm = STRIKE_RADIUS_KM) => {
      const count = strikes.reduce((sum, strike) => {
        const distance = turf.distance(
          turf.point(strike.coordinates),
          point,
          { units: 'kilometers' }
        );
        return sum + (distance <= radiusKm ? 1 : 0);
      }, 0);
      const areaKm2 = Math.PI * radiusKm * radiusKm;
      return areaKm2 > 0 ? count / areaKm2 : 0;
    };

    // Map density to risk level
    const densityToRiskLevel = (density) => {
      if (density > 0.1) return 'high risk';
      if (density > 0.05) return 'moderate risk';
      if (density > 0.02) return 'enhanced risk';
      if (density > 0.01) return 'slight risk';
      return 'low risk';
    };

    // Initialize scoring metrics
    let hits = 0, misses = 0, falseAlarms = 0, quiescent = 0, severityPenalties = 0;
    const strikePoints = strikes.map(s => turf.point(s.coordinates));
    const samplePoints = generateSamplePoints(polygons);
    const allPoints = [...strikePoints, ...samplePoints];

    // Batch polygon containment checks
    const pointsGeoJSON = turf.featureCollection(allPoints);
    const polygonContains = polygons.map(polygon => {
      const poly = turf.polygon(polygon.geometry.coordinates);
      const pointsWithin = turf.pointsWithinPolygon(pointsGeoJSON, poly);
      return pointsWithin.features.map(f => ({
        point: f,
        riskLevel: polygon.properties.Name.toLowerCase()
      }));
    }).flat();

    // Map points to their containing polygons
    const pointToPolygons = new Map();
    allPoints.forEach((point, index) => {
      const polys = polygonContains.filter(pc => pc.point === point).map(pc => pc.riskLevel);
      pointToPolygons.set(index, polys);
    });

    // Process each point
    for (let i = 0; i < allPoints.length; i++) {
      const point = allPoints[i];
      const isStrike = i < strikePoints.length;
      const containingPolys = pointToPolygons.get(i) || [];

      let highestWeight = 0;
      let highestPenalty = 0;
      const inForecast = containingPolys.length > 0;

      // Calculate expected risk based on density
      const density = isStrike ? calculateStrikeDensity(strikes, point) : 0;
      const expectedRisk = densityToRiskLevel(density);
      const expectedWeight = RISK_WEIGHTS[expectedRisk] || 1.0;

      // Find highest risk weight among containing polygons
      containingPolys.forEach(riskLevel => {
        if (RISK_ORDER.includes(riskLevel)) {
          const weight = RISK_WEIGHTS[riskLevel] || 1.0;
          const penalty = PENALTY_MULTIPLIERS[riskLevel] || 1.0;
          if (weight > highestWeight) {
            highestWeight = weight;
            highestPenalty = penalty;
          }
        }
      });

      // Update metrics
      if (isStrike) {
        if (inForecast) {
          hits += highestWeight;
          if (highestWeight < expectedWeight) {
            severityPenalties += (expectedWeight - highestWeight);
          }
        } else {
          misses += 1;
          if (expectedWeight > 1.0) {
            severityPenalties += expectedWeight;
          }
        }
      } else {
        if (inForecast) {
          falseAlarms += highestWeight * highestPenalty;
        } else {
          quiescent += 1;
        }
      }
    }

    // Calculate severe weather bonuses/penalties
    const severePolygons = polygons.filter(p => p.properties.Name.toLowerCase() === 'severe risk');
    let severeScore = 0;
    const maxSevereBonus = 10; // Max contribution to final score
    const severeReportsCount = severeReports.length || 1;
    severePolygons.forEach(polygon => {
      const conditions = polygon.properties.severeConditions || {};
      const poly = turf.polygon(polygon.geometry.coordinates);
      Object.keys(conditions).forEach(condition => {
        const hasReport = severeReports.some(report => {
          if (
            report.location &&
            report.location.length === 2 &&
            report.condition.toLowerCase() === condition &&
            report.observedAt &&
            report.observedAt >= startTime &&
            report.observedAt <= endTime
          ) {
            const point = turf.point(report.location);
            return turf.booleanPointInPolygon(point, poly);
          }
          return false;
        });
        if (conditions[condition] && hasReport) {
          severeScore += 10 / severeReportsCount; // Scaled bonus
        } else if (conditions[condition] && !hasReport) {
          severeScore -= 5 / severeReportsCount; // Scaled penalty
        }
      });
    });
    severeScore = Math.min(maxSevereBonus, Math.max(-maxSevereBonus, severeScore));

    // Calculate normalized score (1–100)
    const total = hits + misses + falseAlarms + quiescent;
    const accuracy = total > 0 ? ((hits + quiescent) / total) * 90 : 0; // Base score 0–90
    const finalScore = Math.min(100, Math.max(1, Math.round(accuracy + severeScore)));

    // Update Firestore with the calculated score
    await db.collection('outlooks').doc(outlookId).update({
      score: finalScore,
      updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
    });

    console.log(`Score calculated for outlook ${outlookId}: ${finalScore}`);
    return finalScore;
  } catch (err) {
    console.error(`Error calculating score for outlook ${outlookId}:`, err);
    return 1; // Minimum score on error
  }
};
    const NavBar = ({ user }) => {
  const [isMenuOpen, setIsMenuOpen] = useState(false);
  const [isOutlooksOpen, setIsOutlooksOpen] = useState(false);

  const toggleMenu = () => {
    setIsMenuOpen(!isMenuOpen);
    if (isOutlooksOpen) setIsOutlooksOpen(false);
  };

  const toggleOutlooks = () => {
    setIsOutlooksOpen(!isOutlooksOpen);
  };

  return (
    <nav className="bg-[#488eaf] text-white p-4">
      <div className="container mx-auto flex justify-between items-center">
        <Link to="/" className="text-2xl font-bold">
          Project Outcaster
        </Link>
        <div className="md:hidden">
          <button onClick={toggleMenu} className="focus:outline-none">
            {isMenuOpen ? '✖' : '☰'}
          </button>
        </div>
        <ul
          className={`md:flex md:items-center md:space-x-6 absolute md:static top-16 left-0 w-full md:w-auto bg-[#488eaf] md:bg-transparent transition-all duration-300 ease-in-out ${
            isMenuOpen ? 'flex flex-col p-4' : 'hidden'
          } z-20`}
        >
          {user ? (
            <>
              <li>
                <Link
                  to="/create"
                  className="block py-2 md:py-0 hover:text-blue-200 text-lg"
                  onClick={() => setIsMenuOpen(false)}
                >
                  Create Outlook
                </Link>
              </li>
              <li className="relative">
                <button
                  className="block py-2 md:py-0 hover:text-blue-200 text-lg w-full text-left md:w-auto flex justify-between items-center"
                  onClick={toggleOutlooks}
                >
                  Outlooks
                  <span className="ml-2 md:hidden">{isOutlooksOpen ? '▲' : '▼'}</span>
                </button>
                <ul
                  className={`${
                    isOutlooksOpen ? 'flex' : 'hidden'
                  } flex-col mt-2 md:absolute md:bg-[#488eaf] md:rounded-lg md:shadow-lg md:w-48 pl-4 md:pl-0 md:mt-1 z-20`}
                >
                  <li>
                    <Link
                      to="/view"
                      className="block py-2 md:py-1 px-4 hover:text-blue-200 text-lg"
                      onClick={() => {
                        setIsOutlooksOpen(false);
                        setIsMenuOpen(false);
                      }}
                    >
                      View Outlooks
                    </Link>
                  </li>
                  <li>
                    <Link
                      to="/archive"
                      className="block py-2 md:py-1 px-4 hover:text-blue-200 text-lg"
                      onClick={() => {
                        setIsOutlooksOpen(false);
                        setIsMenuOpen(false);
                      }}
                    >
                      Archive
                    </Link>
                  </li>
                </ul>
              </li>
              <li>
                <Link
                  to="/your-uploads"
                  className="block py-2 md:py-0 hover:text-blue-200 text-lg"
                  onClick={() => setIsMenuOpen(false)}
                >
                  Your Uploads
                </Link>
              </li>
              <li>
                <Link
                  to="/add-severe-report"
                  className="block py-2 md:py-0 hover:text-blue-200 text-lg"
                  onClick={() => setIsMenuOpen(false)}
                >
                  Add Severe Report
                </Link>
              </li>
              {user.email === 'admin@example.com' && (
                <li>
                  <Link
                    to="/admin"
                    className="block py-2 md:py-0 hover:text-blue-200 text-lg"
                    onClick={() => setIsMenuOpen(false)}
                  >
                    Admin
                  </Link>
                </li>
              )}
              <li>
                <Link
                  to="/leaderboard"
                  className="block py-2 md:py-0 hover:text-blue-200 text-lg"
                  onClick={() => setIsMenuOpen(false)}
                >
                  Leaderboard
                </Link>
              </li>
              <li>
                <button
                  onClick={() => {
                    auth.signOut();
                    setIsMenuOpen(false);
                  }}
                  className="block py-2 md:py-0 hover:text-blue-200 text-lg w-full text-left"
                >
                  Logout
                </button>
              </li>
            </>
          ) : (
            <li>
              <Link
                to="/account"
                className="block py-2 md:py-0 hover:text-blue-200 text-lg"
                onClick={() => setIsMenuOpen(false)}
              >
                Account
              </Link>
            </li>
          )}
        </ul>
      </div>
    </nav>
  );
};

    const WelcomePage = () => {
  const [error, setError] = useState(null);
  const [selectedUsername, setSelectedUsername] = useState(null);
  const [selectedOutlook, setSelectedOutlook] = useState(null);
  const [communityDate, setCommunityDate] = useState(new Date().toISOString().split('T')[0]); // 2025-06-27
  const [communityOutlooks, setCommunityOutlooks] = useState([]);
  const [cellSize, setCellSize] = useState(window.innerWidth < 768 ? 0.3 : 0.1);
  const communityMapRef = useRef(null);
  const forecasterMapRef = useRef(null);
  const communityMapInitialized = useRef(false);
  const forecasterMapInitialized = useRef(false);

  const RISK_LEVELS = {
    'no risk': 0,
    'low risk': 1,
    'slight risk': 2,
    'enhanced risk': 3,
    'moderate risk': 4,
    'high risk': 5
  };

  const RISK_COLORS = {
    'no risk': '#ffffff',
    'low risk': '#66c2a4',
    'slight risk': '#fff200',
    'enhanced risk': '#ff7f27',
    'moderate risk': '#ec1c24',
    'high risk': '#b83dba'
  };

  const getNextAvailableDate = async (currentDate) => {
    try {
      const snapshot = await db.collection('outlooks')
        .where('date', '>=', currentDate)
        .orderBy('date', 'asc')
        .limit(1)
        .get();
      return snapshot.empty ? currentDate : snapshot.docs[0].data().date;
    } catch (err) {
      console.error('Error finding next available date:', err);
      return currentDate;
    }
  };

  const fetchCommunityOutlook = async (date) => {
    console.log('Fetching community outlook for date:', date);
    try {
      const snapshot = await db.collection('outlooks').where('date', '==', date).get();
      const allOutlooks = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        createdAt: doc.data().createdAt?.toDate ? doc.data().createdAt.toDate() : new Date(doc.data().createdAt || Date.now())
      }));
      console.log('Fetched community outlooks:', allOutlooks);

      const latestOutlooks = Object.values(allOutlooks.reduce((acc, outlook) => {
        if (!outlook.username) return acc;
        if (!acc[outlook.username] || new Date(outlook.createdAt) > new Date(acc[outlook.username].createdAt)) {
          acc[outlook.username] = outlook;
        }
        return acc;
      }, {}));

      const allUserOutlooks = await db.collection('outlooks').get();
      const userScores = allUserOutlooks.docs.reduce((acc, doc) => {
        const { username, score } = doc.data();
        if (!username) return acc;
        acc[username] = acc[username] || { total: 0, count: 0 };
        if (score != null && !isNaN(score)) {
          acc[username].total += score;
          acc[username].count += 1;
        }
        return acc;
      }, {});

      const weightedOutlooks = latestOutlooks.map(outlook => ({
        ...outlook,
        weight: userScores[outlook.username]?.count > 0
          ? userScores[outlook.username].total / userScores[outlook.username].count || 1
          : 1
      }));

      setCommunityOutlooks(weightedOutlooks);
      updateCommunityMap(weightedOutlooks, date);
    } catch (err) {
      console.error('Error fetching community outlook:', err);
      setError(`Failed to load community forecast: ${err.message}`);
    }
  };

  const initializeCommunityMap = () => {
    if (communityMapInitialized.current || !window.L || !document.getElementById('community-map')) return;
    try {
      console.log('Initializing community map');
      const map = L.map('community-map', {
        zoomControl: true, minZoom: 5, maxZoom: 10,
        maxBounds: [[UK_BBOX[1], UK_BBOX[0]], [UK_BBOX[3], UK_BBOX[2]]]
      }).setView([54.5, -3], 6);
      communityMapRef.current = map;
      communityMapInitialized.current = true;
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19, attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
      }).addTo(map).on('tileerror', (error) => {
        console.error('Community map tile error:', error);
        setError('Failed to load community map tiles');
      });
      if (communityOutlooks.length) updateCommunityMap(communityOutlooks, communityDate);
    } catch (err) {
      console.error('Error initializing community map:', err);
      setError('Failed to initialize community map');
    }
  };

  const initializeForecasterMap = (outlook) => {
    if (forecasterMapInitialized.current || !window.L || !document.getElementById('welcome-map')) return;
    try {
      console.log('Initializing top forecaster map');
      const map = L.map('welcome-map', {
        zoomControl: true, minZoom: 5, maxZoom: 10,
        maxBounds: [[UK_BBOX[1], UK_BBOX[0]], [UK_BBOX[3], UK_BBOX[2]]]
      }).setView([54.5, -3], 6);
      forecasterMapRef.current = map;
      forecasterMapInitialized.current = true;
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19, attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
      }).addTo(map).on('tileerror', (error) => {
        console.error('Top forecaster map tile error:', error);
        setError('Failed to load map tiles');
      });

      if (outlook?.polygons?.length) {
        const parsedPolygons = outlook.polygons.map(p => {
          try {
            return {
              ...p,
              geometry: { ...p.geometry, coordinates: JSON.parse(p.geometry.coordinates) || p.geometry.coordinates },
              properties: { ...p.properties, Name: p.properties.Name || 'low risk', color: p.properties.color || RISK_COLORS[p.properties.Name?.toLowerCase() || 'low risk'] }
            };
          } catch (err) {
            console.error('Error parsing polygon:', p, err);
            return null;
          }
        }).filter(p => p);
        console.log('Parsed polygons for WelcomePage:', parsedPolygons);

        const polygonsByRisk = RISK_ORDER.reduce((acc, risk) => {
          acc[risk] = parsedPolygons.filter(p => p.properties.Name.toLowerCase() === risk);
          return acc;
        }, {});

        RISK_ORDER.forEach(risk => {
          if (polygonsByRisk[risk].length) {
            L.geoJSON(polygonsByRisk[risk], {
              style: feature => ({
                color: RISK_COLORS[feature.properties.Name?.toLowerCase()] || '#66c2a4',
                fillColor: risk === 'severe risk' ? 'transparent' : RISK_COLORS[feature.properties.Name?.toLowerCase()] || '#66c2a4',
                fillOpacity: risk === 'severe risk' ? 0 : 0.4,
                weight: 2
              })
            }).addTo(map);
            console.log('Added GeoJSON layer for', risk);
          }
        });
      } else {
        console.warn('No valid outlook provided for top forecaster map:', outlook);
        setError('No valid forecast areas available');
      }
    } catch (err) {
      console.error('Error initializing top forecaster map:', err);
      setError('Failed to initialize top forecaster map');
    }
  };

  const updateCommunityMap = (outlooks, date) => {
    if (!communityMapRef.current) {
      console.warn('Community map not available');
      setError('Failed to update community map: container not found');
      return;
    }
    console.log('Updating community map');
    communityMapRef.current.eachLayer(layer => {
      if (layer instanceof L.Rectangle || layer instanceof L.GeoJSON) communityMapRef.current.removeLayer(layer);
    });

    if (!outlooks.length) {
      console.warn('No outlooks provided for community map');
      setError('No community forecast available for selected date');
      return;
    }

    const allPolygons = outlooks.flatMap(outlook =>
      (outlook.polygons || []).filter(p => p.properties.Name.toLowerCase() !== 'severe risk').map(p => {
        try {
          return {
            ...p,
            geometry: { ...p.geometry, coordinates: JSON.parse(p.geometry.coordinates) || p.geometry.coordinates },
            properties: { ...p.properties, Name: p.properties.Name || 'low risk', weight: outlook.weight }
          };
        } catch (err) {
          console.error('Error parsing polygon:', p, err);
          return null;
        }
      }).filter(p => p)
    );

    if (!allPolygons.length) {
      console.warn('No valid polygons for community outlook');
      setError('No valid community forecast areas');
      return;
    }

    const bbox = [UK_BBOX[0], UK_BBOX[1], UK_BBOX[2], UK_BBOX[3]];
    const grid = turf.pointGrid(bbox, cellSize, { units: 'degrees' });
    const gridCells = grid.features.map(point => {
      let totalWeightedScore = 0, totalWeight = 0;
      allPolygons.forEach(polygon => {
        if (turf.booleanPointInPolygon(point, polygon)) {
          const riskLevel = polygon.properties.Name.toLowerCase();
          const score = RISK_LEVELS[riskLevel] || 0;
          const weight = polygon.properties.weight || 1;
          totalWeightedScore += score * weight;
          totalWeight += weight;
        }
      });
      const meanScore = totalWeight > 0 ? totalWeightedScore / totalWeight : 0;
      const roundedScore = Math.round(meanScore);
      const riskLevel = Object.keys(RISK_LEVELS).find(key => RISK_LEVELS[key] === roundedScore) || 'no risk';
      const [lng, lat] = point.geometry.coordinates;
      return {
        type: 'Feature',
        geometry: {
          type: 'Polygon',
          coordinates: [[
            [lng - cellSize / 2, lat - cellSize / 2],
            [lng + cellSize / 2, lat - cellSize / 2],
            [lng + cellSize / 2, lat + cellSize / 2],
            [lng - cellSize / 2, lat + cellSize / 2],
            [lng - cellSize / 2, lat - cellSize / 2]
          ]]
        },
        properties: { Name: riskLevel, score: roundedScore, color: RISK_COLORS[riskLevel] || '#ffffff' }
      };
    });

    console.log('Computed grid cells for community map:', gridCells);

    gridCells.forEach(cell => {
      const bounds = [
        [cell.geometry.coordinates[0][0][1], cell.geometry.coordinates[0][0][0]],
        [cell.geometry.coordinates[0][2][1], cell.geometry.coordinates[0][2][0]]
      ];
      L.rectangle(bounds, {
        color: cell.properties.color,
        fillColor: cell.properties.color,
        fillOpacity: 0.4,
        weight: 1
      }).bindPopup(`Risk Level: ${cell.properties.Name}<br>Score: ${cell.properties.score}`).addTo(communityMapRef.current);
    });

    requestAnimationFrame(() => {
      if (communityMapRef.current) communityMapRef.current.invalidateSize();
      console.log('Community map updated, position:', document.getElementById('community-map')?.getBoundingClientRect());
    });
  };

  useEffect(() => {
    localStorage.setItem('welcomePageVisited', 'true');
    console.log('Welcome page visited, flag set');

    const fetchAndDisplayOutlook = async () => {
      try {
        const currentDate = new Date().toISOString().split('T')[0]; // 2025-06-27
        const snapshot = await db.collection('outlooks').where('date', '>=', currentDate).get();
        const outlooks = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data(),
          createdAt: doc.data().createdAt?.toDate ? doc.data().createdAt.toDate() : new Date(doc.data().createdAt || Date.now())
        }));
        console.log('Fetched outlooks:', outlooks);

        if (!outlooks.length) {
          setError('No forecasts available for today or future');
          return;
        }

        const averagedScores = outlooks.reduce((acc, curr) => {
          const { username, score } = curr;
          if (!username) {
            console.warn('Outlook missing username:', curr.id, curr);
            return acc;
          }
          acc[username] = acc[username] || { total: 0, count: 0, outlooks: [] };
          acc[username].outlooks.push(curr);
          if (score != null && !isNaN(score)) {
            acc[username].total += score;
            acc[username].count += 1;
          }
          return acc;
        }, {});

        const sortedUsers = Object.entries(averagedScores).map(([username, data]) => ({
          username,
          avgScore: data.count > 0 ? data.total / data.count : 0,
          outlookCount: data.outlooks.length
        })).sort((a, b) => (a.avgScore === b.avgScore ? b.outlookCount - a.outlookCount : b.avgScore - a.avgScore));

        let selectedOutlook = null, selectedUsername = null;
        if (sortedUsers.length) {
          const topUser = sortedUsers[0].username;
          const userOutlooks = averagedScores[topUser].outlooks.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
          selectedOutlook = userOutlooks[0];
          selectedUsername = topUser;
        } else {
          selectedOutlook = outlooks.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))[0];
          selectedUsername = selectedOutlook.username || 'Unknown';
        }

        if (!selectedOutlook) {
          setError('No valid forecast available to display');
          return;
        }

        setSelectedUsername(selectedUsername);
        setSelectedOutlook(selectedOutlook);
        initializeCommunityMap();
        initializeForecasterMap(selectedOutlook);

        const initialDate = await getNextAvailableDate(currentDate);
        setCommunityDate(initialDate);
      } catch (err) {
        console.error('Error fetching or displaying outlook:', err);
        if (err.code === 'failed-precondition' && err.message.includes('index')) {
          setError('Database index required. Please contact the administrator.');
        } else {
          setError(`Failed to load forecast data: ${err.message}`);
        }
      }
    };

    fetchAndDisplayOutlook();

    return () => {
      if (communityMapRef.current) {
        communityMapRef.current.remove();
        communityMapRef.current = null;
        communityMapInitialized.current = false;
      }
      if (forecasterMapRef.current) {
        forecasterMapRef.current.remove();
        forecasterMapRef.current = null;
        forecasterMapInitialized.current = false;
      }
    };
  }, []);

  useEffect(() => {
    console.log('Community date or cell size changed:', { communityDate, cellSize });
    fetchCommunityOutlook(communityDate);
  }, [communityDate, cellSize]);

  const handleDateChange = (e) => {
    const newDate = e.target.value;
    console.log('Date picker selected:', newDate);
    setCommunityDate(newDate);
  };

  const handleCellSizeChange = (e) => {
    const newCellSize = parseFloat(e.target.value);
    console.log('Cell size changed:', newCellSize);
    setCellSize(newCellSize);
  };

  const formatTimestamp = (timestamp) => {
    if (!timestamp) return 'Unknown';
    try {
      const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
      return date.toLocaleString('en-GB', {
        day: '2-digit', month: '2-digit', year: 'numeric',
        hour: '2-digit', minute: '2-digit', timeZone: 'Europe/London'
      });
    } catch {
      return 'Unknown';
    }
  };

  const formatValidityPeriod = (dateString) => {
    if (!dateString) return 'Unknown';
    try {
      const forecastDate = new Date(dateString);
      const nextDay = new Date(forecastDate);
      nextDay.setDate(forecastDate.getDate() + 1);
      return `${forecastDate.toLocaleDateString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric' })} 06:00 - ${nextDay.toLocaleDateString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric' })} 05:59`;
    } catch {
      return 'Unknown';
    }
  };

  const getVersion = (outlook) => outlook?.version || 'Unknown';

  return (
  <div className="p-4 container mx-auto">
    <h1 className="text-2xl md:text-3xl font-bold text-gray-800 mb-4">Welcome to Project Outcaster</h1>
    {error && <p className="text-red-500 mb-4 bg-red-100 p-3 rounded-lg">{error}</p>}
    
    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
      <div className="bg-white p-4 rounded-lg shadow-md">
        <h2 className="text-xl md:text-2xl font-semibold text-gray-700 mb-2">Community Outlook Map</h2>
        <p className="text-gray-600 mb-2 max-w-md">
          <span style={{ whiteSpace: 'nowrap' }}>Community forecast for 27/06/2025 06:00 - 28/06/2025 05:59</span><br />
          Based on 4 user submissions
        </p>
        <div id="community-map" className="h-[300px] md:h-[500px] w-full rounded-lg shadow-md"></div>
        <div className="mt-4">
          
          <div className="flex flex-col gap-2">
            <div className="flex items-center gap-2">
              <label htmlFor="community-date" className="text-gray-600">Select Date:</label>
              <input
                id="community-date"
                type="date"
                value={communityDate}
                onChange={handleDateChange}
                className="p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
            </div>
            <div className="flex flex-col gap-1">
              <label htmlFor="resolution-slider" className="text-gray-600">Grid Resolution: {cellSize.toFixed(2)}°</label>
              <input
                id="resolution-slider"
                type="range"
                min="0.05"
                max="0.5"
                step="0.05"
                value={cellSize}
                onChange={handleCellSizeChange}
                className="w-full md:w-1/2"
              />
            </div>
          </div>
          <p className="text-gray-600 mb-2 max-w-md">
            <span style={{ whiteSpace: 'nowrap' }}>Community convective outlook based on users' submitted forecast </span><br />
            and their forecasting accuracy
          </p>
        </div>
      </div>
      <div className="bg-white p-4 rounded-lg shadow-md">
        <h2 className="text-xl md:text-2xl font-semibold text-gray-700 mb-2">Top Forecaster's Outlook Map</h2>
        <p className="text-gray-600 mb-2 max-w-md">
          {selectedOutlook && selectedUsername ? (
            <>
              Viewing {selectedUsername}'s latest forecast, valid for{' '}
              {formatValidityPeriod(selectedOutlook.date)}, {getVersion(selectedOutlook)}, published{' '}
              {formatTimestamp(selectedOutlook.createdAt)}
            </>
          ) : (
            'No forecast selected'
          )}
        </p>
        <div id="welcome-map" className="h-[300px] md:h-[500px] w-full rounded-lg shadow-md"></div>
      </div>
    </div>
  </div>
);
};

    const CreateOutlookPage = ({ user, username, email }) => {
      const [drawnItems, setDrawnItems] = useState([]);
      const [riskLevel, setRiskLevel] = useState('low risk');
      const [severeConditions, setSevereConditions] = useState({
        rainfall: false,
        hail: false,
        tornado: false,
        gusts: false
      });
      const [selectedPolygonId, setSelectedPolygonId] = useState(null);
      const [dataError, setDataError] = useState(null);
      const [sizeError, setSizeError] = useState(null);
      const tomorrow = new Date();
      tomorrow.setDate(tomorrow.getDate() + 1);
      const [forecastDate, setForecastDate] = useState(tomorrow.toISOString().split('T')[0]);
      const [drafts, setDrafts] = useState([]);
      const [selectedDraftId, setSelectedDraftId] = useState('');
      const [draftName, setDraftName] = useState('');
      const mapRef = useRef(null);
      const drawRef = useRef(null);

      const getNextVersion = async (collection, email, date) => {
        try {
          const snapshot = await db.collection(collection)
            .where('email', '==', email)
            .where('date', '==', date)
            .get();
          const count = snapshot.size;
          return `version ${count + 1}`;
        } catch (err) {
          console.error(`Error fetching version count for ${collection}:`, err);
          return 'version 1';
        }
      };

      const validatePolygonSizes = (polygons) => {
        console.log('Validating polygons:', polygons);
        for (let i = 0; i < polygons.length; i++) {
          const poly1 = polygons[i];
          if (!poly1.geometry || !poly1.geometry.coordinates || !poly1.properties.Name) {
            return `Error: Invalid polygon data at index ${i}`;
          }
          if (poly1.properties.Name.toLowerCase() === 'severe risk') continue;
          try {
            const area1 = turf.area(turf.polygon(poly1.geometry.coordinates));
            const riskIndex1 = RISK_ORDER.indexOf(poly1.properties.Name.toLowerCase());
            for (let k = i + 1; k < polygons.length; k++) {
              const poly2 = polygons[k];
              if (!poly2.geometry || !poly2.geometry.coordinates) {
                return `Error: Invalid polygon data at index ${k}`;
              }
              if (poly2.properties.Name.toLowerCase() === 'severe risk') continue;
              const area2 = turf.area(turf.polygon(poly2.geometry.coordinates));
              const riskIndex2 = RISK_ORDER.indexOf(poly2.properties.Name.toLowerCase());
              if (riskIndex1 > riskIndex2 && area1 > area2) {
                return `Error: ${poly1.properties.Name} area must be smaller than ${poly2.properties.Name} area.`;
              }
              if (riskIndex2 > riskIndex1 && area2 > area1) {
                return `Error: ${poly2.properties.Name} area must be smaller than ${poly1.properties.Name} area.`;
              }
            }
          } catch (err) {
            console.error('Error in validatePolygonSizes:', err);
            return `Error validating polygon sizes: ${err.message}`;
          }
        }
        return null;
      };

      const updateDrawnFeatures = () => {
        console.log('Updating drawn features');
        const features = drawRef.current.getAll().features;
        features.forEach(feature => {
          if (!feature.properties?.Name) {
            feature.properties = {
              Name: riskLevel,
              color: RISK_COLORS[riskLevel],
              severeConditions: riskLevel === 'severe risk' ? severeConditions : {}
            };
            console.log('Set properties for feature', feature.id, ':', feature.properties);
          }
        });
        features.sort((a, b) => RISK_ORDER.indexOf(b.properties.Name.toLowerCase()) - RISK_ORDER.indexOf(a.properties.Name.toLowerCase()));
        setDrawnItems(features);
        if (mapRef.current.getSource('drawnFeatures')) {
          mapRef.current.getSource('drawnFeatures').setData({
            type: 'FeatureCollection',
            features: features
          });
          console.log('Updated map source with features');
        }
      };

      useEffect(() => {
        waitForMapbox(() => {
          if (!window.mapboxgl) {
            console.error('Mapbox GL JS not loaded');
            setDataError('Failed to load map. Please refresh the page.');
            return;
          }
          mapboxgl.accessToken = 'pk.eyJ1IjoiaGFuZHJ5MjAxOTEwMjYiLCJhIjoiY21jYWg2eG1lMDNkYTJxczVyOWM5bW9mciJ9.bA-qxiByTB_RseY1fgU4rg';
          const map = new mapboxgl.Map({
            container: 'create-map',
            style: 'mapbox://styles/mapbox/streets-v11',
            center: [-3, 54.5],
            zoom: 6,
            minZoom: 3,
            maxZoom: 10,
            maxBounds: [[UK_BBOX[0], UK_BBOX[1]], [UK_BBOX[2], UK_BBOX[3]]]
          });
          mapRef.current = map;

          // Add this line to resize the map after initialization
          map.on('load', () => {
            map.resize();
            console.log('Map resized after load');
          });

          const draw = new MapboxDraw({
            displayControlsDefault: false,
            controls: {
              polygon: true,
              trash: true
            },
            defaultMode: 'draw_polygon',
            styles: [
              {
                id: 'gl-draw-polygon-fill-inactive',
                type: 'fill',
                filter: ['all', ['==', 'active', 'false'], ['==', '$type', 'Polygon']],
                paint: {
                  'fill-color': ['get', 'color'],
                  'fill-opacity': ['case', ['==', ['get', 'Name'], 'severe risk'], 0, 0.4]
                }
              },
              {
                id: 'gl-draw-polygon-stroke-inactive',
                type: 'line',
                filter: ['all', ['==', 'active', 'false'], ['==', '$type', 'Polygon']],
                paint: {
                  'line-color': ['get', 'color'],
                  'line-width': 2
                }
              },
              {
                id: 'gl-draw-polygon-fill-active',
                type: 'fill',
                filter: ['all', ['==', 'active', 'true'], ['==', '$type', 'Polygon']],
                paint: {
                  'fill-color': ['get', 'color'],
                  'fill-opacity': ['case', ['==', ['get', 'Name'], 'severe risk'], 0, 0.4]
                }
              },
              {
                id: 'gl-draw-polygon-stroke-active',
                type: 'line',
                filter: ['all', ['==', 'active', 'true'], ['==', '$type', 'Polygon']],
                paint: {
                  'line-color': ['get', 'color'],
                  'line-width': 3
                }
              },
              {
                id: 'gl-draw-polygon-midpoint',
                type: 'circle',
                filter: ['all', ['==', '$type', 'Point'], ['==', 'meta', 'midpoint']],
                paint: {
                  'circle-radius': 3,
                  'circle-color': '#fbb03b'
                }
              },
              {
                id: 'gl-draw-polygon-vertex-inactive',
                type: 'circle',
                filter: ['all', ['==', 'meta', 'vertex'], ['==', '$type', 'Point'], ['!=', 'mode', 'static']],
                paint: {
                  'circle-radius': 5,
                  'circle-color': '#fff'
                }
              }
            ]
          });
          map.addControl(draw);
          drawRef.current = draw;

          map.on('draw.create', (e) => {
            console.log('Draw create event:', e);
            const feature = e.features[0];
            // Alter this block to ensure the polygon uses the current riskLevel
            feature.properties = {
              Name: riskLevel,
              color: RISK_COLORS[riskLevel],
              severeConditions: riskLevel === 'severe risk' ? severeConditions : {}
            };
            console.log('Created feature', feature.id, 'with properties:', feature.properties);
            const newItems = [...drawnItems, feature];
            const validationError = validatePolygonSizes(newItems);
            if (validationError) {
              setSizeError(validationError); // Corrected line
              draw.delete(feature.id);
            } else {
              setSizeError(null);
              setDrawnItems(newItems);
              setSelectedPolygonId(feature.id);
            }
            updateDrawnFeatures();
          });

          map.on('draw.update', updateDrawnFeatures);
          map.on('draw.delete', updateDrawnFeatures);
          map.on('draw.selectionchange', (e) => {
            const selected = e.features[0]?.id;
            setSelectedPolygonId(selected || null);
            if (selected) {
              const feature = drawRef.current.get(selected);
              if (feature) {
                setRiskLevel(feature.properties.Name);
                if (feature.properties.Name === 'severe risk') {
                  setSevereConditions(feature.properties.severeConditions || {
                    rainfall: false,
                    hail: false,
                    tornado: false,
                    gusts: false
                  });
                } else {
                  setSevereConditions({
                    rainfall: false,
                    hail: false,
                    tornado: false,
                    gusts: false
                  });
                }
                drawRef.current.changeMode('direct_select', { featureId: selected });
              }
            }
          });

          map.on('draw.modechange', (e) => {
            console.log('Mode changed to:', e.mode);
            if (e.mode === 'simple_select' && selectedPolygonId) {
              drawRef.current.changeMode('direct_select', { featureId: selectedPolygonId });
            }
          });

          map.on('load', () => {
            console.log('Map loaded');
            map.addSource('drawnFeatures', {
              type: 'geojson',
              data: { type: 'FeatureCollection', features: [] }
            });
            map.addLayer({
              id: 'drawnPolygons',
              type: 'fill',
              source: 'drawnFeatures',
              filter: ['!=', 'Name', 'severe risk'],
              paint: {
                'fill-color': ['get', 'color'],
                'fill-opacity': [
                  'interpolate',
                  ['linear'],
                  ['zoom'],
                  3, 0.2,
                  10, 0.4
                ]
              }
            });
            map.addLayer({
              id: 'drawnPolygonsOutline',
              type: 'line',
              source: 'drawnFeatures',
              paint: {
                'line-color': ['case', ['==', ['get', 'Name'], 'severe risk'], '#000000', ['get', 'color']],
                'line-width': 2
              }
            });
            map.addLayer({
              id: 'drawnSeverePolygons',
              type: 'fill',
              source: 'drawnFeatures',
              filter: ['==', 'Name', 'severe risk'],
              paint: {
                'fill-opacity': 0
              }
            });
          });

          db.collection('drafts')
            .where('email', '==', email)
            .get()
            .then(snapshot => {
              const draftsData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
              console.log('Fetched drafts:', draftsData);
              setDrafts(draftsData);
            })
            .catch(err => {
              console.error('Error fetching drafts:', err);
              setDataError('Failed to load drafts');
            });

          return () => {
            console.log('Cleaning up CreateOutlookPage map');
            map.remove();
          };
        });
      }, [email]);

      const updateRiskLevel = (newRiskLevel) => {
        console.log('Updating risk level to:', newRiskLevel);
        setRiskLevel(newRiskLevel);
        if (selectedPolygonId) {
          const feature = drawRef.current.get(selectedPolygonId);
          if (feature) {
            drawRef.current.setFeatureProperty(selectedPolygonId, 'Name', newRiskLevel);
            drawRef.current.setFeatureProperty(selectedPolygonId, 'color', RISK_COLORS[newRiskLevel]);
            drawRef.current.setFeatureProperty(selectedPolygonId, 'severeConditions', newRiskLevel === 'severe risk' ? severeConditions : {});
            console.log('Updated feature', selectedPolygonId, 'to', newRiskLevel);
            updateDrawnFeatures();
          }
        }
      };

      const updateSevereConditions = (newConditions) => {
        console.log('Updating severe conditions:', newConditions);
        setSevereConditions(newConditions);
        if (selectedPolygonId && riskLevel === 'severe risk') {
          drawRef.current.setFeatureProperty(selectedPolygonId, 'severeConditions', newConditions);
          console.log('Updated severe conditions for feature', selectedPolygonId);
          updateDrawnFeatures();
        }
      };

      const submitOutlook = async () => {
        console.log('Submitting outlook with drawnItems:', drawnItems, 'forecast date:', forecastDate);
        if (drawnItems.length === 0) {
          console.warn('No polygons drawn');
          alert('Please draw at least one polygon before submitting.');
          return;
        }
        if (!forecastDate) {
          console.warn('No forecast date provided');
          alert('Please select a forecast date.');
          return;
        }
        if (email !== 'admin@example.com') {
          const currentDate = new Date().toISOString().split('T')[0]; 
          const selectedDateTime = new Date(forecastDate);
          if (selectedDateTime <= currentDate) {
            console.warn('Selected date is invalid or in the past:', forecastDate);
            alert('Forecast date cannot be in the past or today.');
            return;
          }
        }
        const validationError = validatePolygonSizes(drawnItems);
        if (validationError) {
          console.warn('Validation error:', validationError);
          alert(`Validation error: ${validationError}`);
          return;
        }

        try {
          const serializedPolygons = drawnItems.map(polygon => ({
            ...polygon,
            geometry: {
              ...polygon.geometry,
              coordinates: JSON.stringify(polygon.geometry.coordinates)
            },
            properties: {
              ...polygon.properties,
              Name: polygon.properties.Name,
              color: RISK_COLORS[polygon.properties.Name.toLowerCase()]
            }
          }));
          console.log('Serialized polygons for Firestore:', serializedPolygons);

          const version = await getNextVersion('outlooks', email, forecastDate);
          const outlookRef = await db.collection('outlooks').add({
            username,
            email: email || user.email,
            polygons: serializedPolygons,
            date: forecastDate,
            severeConditions: drawnItems.some(item => item.properties.Name === 'severe risk') ? severeConditions : {},
            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
            score: null,
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            version,
            likes: []
          });
          console.log('Outlook saved, ID:', outlookRef.id, 'Version:', version);

          alert('Outlook submitted successfully! Score will be calculated after the forecast period ends.');
          setDrawnItems([]);
          setSelectedPolygonId(null);
          drawRef.current.deleteAll();
          if (mapRef.current.getSource('drawnFeatures')) {
            mapRef.current.getSource('drawnFeatures').setData({
              type: 'FeatureCollection',
              features: []
            });
          }
        } catch (err) {
          console.error('Error submitting outlook:', err);
          alert(`Submission failed: ${err.message}`);
        }
      };

      const saveDraft = async () => {
        if (!draftName) {
          alert('Please enter a name for the draft.');
          return;
        }
        if (drawnItems.length === 0) {
          alert('Please draw at least one polygon to save as a draft.');
          return;
        }
        if (!forecastDate) {
          alert('Please select a forecast date.');
          return;
        }
        try {
          const serializedPolygons = drawnItems.map(polygon => ({
            ...polygon,
            geometry: {
              ...polygon.geometry,
              coordinates: JSON.stringify(polygon.geometry.coordinates)
            },
            properties: {
              ...polygon.properties,
              Name: polygon.properties.Name,
              color: RISK_COLORS[polygon.properties.Name.toLowerCase()]
            }
          }));
          const version = await getNextVersion('drafts', email, forecastDate);
          const draftData = {
            username,
            email: email || user.email,
            polygons: serializedPolygons,
            date: forecastDate,
            name: draftName,
            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            version
          };
          let draftRef;
          if (selectedDraftId) {
            draftRef = await db.collection('drafts').doc(selectedDraftId).set(draftData);
            console.log('Draft updated, ID:', selectedDraftId, 'Version:', version);
          } else {
            draftRef = await db.collection('drafts').add(draftData);
            console.log('Draft saved, ID:', draftRef.id, 'Version:', version);
            setSelectedDraftId(draftRef.id);
          }
          const draftsSnapshot = await db.collection('drafts').where('email', '==', email).get();
          setDrafts(draftsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
          alert('Draft saved successfully!');
        } catch (err) {
          console.error('Error saving draft:', err);
          alert(`Failed to save draft: ${err.message}`);
        }
      };

      const loadDraft = (draftId) => {
        const draft = drafts.find(d => d.id === draftId);
        if (!draft) {
          console.error('Draft not found:', draftId);
          return;
        }
        console.log('Loading draft:', draftId, draft);
        setSelectedDraftId(draftId);
        setDraftName(draft.name);
        setForecastDate(draft.date);
        const parsedPolygons = draft.polygons.map(p => ({
          ...p,
          geometry: {
            ...p.geometry,
            coordinates: JSON.parse(p.geometry.coordinates)
          }
        }));
        setDrawnItems(parsedPolygons);
        drawRef.current.deleteAll();
        parsedPolygons.forEach(feature => {
          drawRef.current.add(feature);
        });
        if (mapRef.current.getSource('drawnFeatures')) {
          mapRef.current.getSource('drawnFeatures').setData({
            type: 'FeatureCollection',
            features: parsedPolygons
          });
        }
        setSelectedPolygonId(null);
        setRiskLevel('low risk');
        setSevereConditions({
          rainfall: false,
          hail: false,
          tornado: false,
          gusts: false
        });
      };

      const deletePolygon = (id) => {
        console.log('Deleting polygon:', id);
        drawRef.current.delete(id);
        setDrawnItems(drawnItems.filter(item => item.id !== id));
        setSelectedPolygonId(null);
        setRiskLevel('low risk');
        setSevereConditions({
          rainfall: false,
          hail: false,
          tornado: false,
          gusts: false
        });
        updateDrawnFeatures();
      };

      const handleSevereChange = (e) => {
        console.log('Handling severe change:', e.target.name, e.target.checked);
        const newConditions = {
          ...severeConditions,
          [e.target.name]: e.target.checked
        };
        updateSevereConditions(newConditions);
      };

      const clearPolygons = () => {
        console.log('Clearing polygons');
        setDrawnItems([]);
        setSelectedPolygonId(null);
        setSelectedDraftId('');
        setDraftName('');
        setRiskLevel('low risk');
        setSevereConditions({
          rainfall: false,
          hail: false,
          tornado: false,
          gusts: false
        });
        drawRef.current.deleteAll();
        setSizeError(null);
        if (mapRef.current.getSource('drawnFeatures')) {
          mapRef.current.getSource('drawnFeatures').setData({
            type: 'FeatureCollection',
            features: []
          });
          console.log('Cleared map source');
        }
      };

      return (
        <div className="p-6 container mx-auto">
          <h1 className="text-3xl font-bold text-gray-800 mb-6">Create Your Outlook</h1>
          <p className="text-gray-600 mb-4">Draw risk areas on the map and select their risk levels for the chosen date (06:00 to next day 05:59):</p>
          {dataError && <p className="text-red-500 mb-4 bg-red-100 p-3 rounded-lg">{dataError}</p>}
          {sizeError && <p className="text-red-500 mb-4 bg-red-100 p-3 rounded-lg">{sizeError}</p>}
          <div className="flex flex-col md:flex-row gap-6">
            <div className="md:w-1/3 bg-white p-6 rounded-lg shadow-md">
              <h2 className="text-xl font-semibold text-gray-700 mb-4">Draft Management</h2>
              <input
                type="text"
                value={draftName}
                onChange={e => setDraftName(e.target.value)}
                placeholder="Draft Name"
                className="w-full p-2 mb-4 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
              <select
                value={selectedDraftId}
                onChange={e => loadDraft(e.target.value)}
                className="w-full p-2 mb-4 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                <option value="">Select a Draft</option>
                {drafts.map(draft => (
                  <option key={draft.id} value={draft.id}>{draft.name} ({draft.date})</option>
                ))}
              </select>
              <button
                onClick={saveDraft}
                className="w-full bg-purple-600 text-white p-3 mb-4 rounded-lg hover:bg-purple-700 transition"
              >
                {selectedDraftId ? 'Update Draft' : 'Save as Draft'}
              </button>
              <h2 className="text-xl font-semibold text-gray-700 mb-4">Forecast Date</h2>
              <input
                type="date"
                value={forecastDate}
                onChange={e => setForecastDate(e.target.value)}
                min={email === 'admin@example.com' ? undefined : new Date().toISOString().split('T')[0]}
                className="w-full p-2 mb-4 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
              <h2 className="text-xl font-semibold text-gray-700 mb-4">Risk Level</h2>
              <select
                value={riskLevel}
                onChange={e => updateRiskLevel(e.target.value)}
                className="w-full p-2 mb-4 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                {RISK_ORDER.map(risk => (
                  <option key={risk} value={risk}>{risk.charAt(0).toUpperCase() + risk.slice(1)}</option>
                ))}
              </select>
              {riskLevel === 'severe risk' && selectedPolygonId && (
                <>
                  <h2 className="text-xl font-semibold text-gray-700 mb-4">Severe Conditions</h2>
                  {['rainfall', 'hail', 'tornado', 'gusts'].map(condition => (
                    <label key={condition} className="flex items-center mb-2">
                      <input
                        type="checkbox"
                        name={condition}
                        checked={severeConditions[condition]}
                        onChange={handleSevereChange}
                        className="mr-2 h-5 w-5 text-blue-600"
                      />
                      <span className="text-gray-600">
                        {condition.charAt(0).toUpperCase() + condition.slice(1)}
                        {condition === 'rainfall' && ' (>25mm/3hr)'}
                        {condition === 'hail' && ' (>2cm)'}
                        {condition === 'tornado' && ''}
                        {condition === 'gusts' && ' (>55mph)'}
                      </span>
                    </label>
                  ))}
                </>
              )}
              <h2 className="text-xl font-semibold text-gray-700 mb-4">Drawn Polygons</h2>
              <ul className="space-y-2 mb-4 max-h-60 overflow-y-auto">
                {drawnItems.map(item => (
                  <li
                    key={item.id}
                    className={`p-2 cursor-pointer rounded-lg ${selectedPolygonId === item.id ? 'bg-blue-100' : 'hover:bg-gray-100'}`}
                    onClick={() => {
                      setSelectedPolygonId(item.id);
                      setRiskLevel(item.properties.Name);
                      if (item.properties.Name === 'severe risk') {
                        setSevereConditions(item.properties.severeConditions || {
                          rainfall: false,
                          hail: false,
                          tornado: false,
                          gusts: false
                        });
                      } else {
                        setSevereConditions({
                          rainfall: false,
                          hail: false,
                          tornado: false,
                          gusts: false
                        });
                      }
                      drawRef.current.changeMode('direct_select', { featureId: item.id });
                    }}
                  >
                    {item.properties.Name} (ID: {item.id.slice(0, 8)})
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        deletePolygon(item.id);
                      }}
                      className="ml-2 text-red-500 hover:text-red-700"
                    >
                      Delete
                    </button>
                  </li>
                ))}
              </ul>
              <div className="flex space-x-4">
                <button
                  onClick={submitOutlook}
                  className="bg-blue-600 text-white p-3 rounded-lg hover:bg-blue-700 transition disabled:bg-blue-400"
                  disabled={sizeError}
                >
                  Submit Outlook
                </button>
                <button
                  onClick={clearPolygons}
                  className="bg-red-600 text-white p-3 rounded-lg hover:bg-red-700 transition"
                >
                  Clear Polygons
                </button>
              </div>
            </div>
            <div className="md:w-2/3">
              <div id="create-map" className="h-[700px] w-full rounded-lg shadow-md"></div>
            </div>
          </div>
        </div>
      );
    };
    const ViewOutlookPage = ({ user }) => {
      const [outlooks, setOutlooks] = useState([]);
      const [filteredOutlooks, setFilteredOutlooks] = useState([]);
      const [selectedOutlook, setSelectedOutlook] = useState(null);
      const [error, setError] = useState(null);
      const [dateFilter, setDateFilter] = useState('');
      const [searchUsername, setSearchUsername] = useState('');
      const [sortBy, setSortBy] = useState('latest');
      const mapRef = useRef(null);
      const geoJsonLayersRef = useRef([]);

      const handleLike = async (outlookId) => {
        if (!user) {
          alert('Please log in to like an outlook.');
          return;
        }
        try {
          const outlookRef = db.collection('outlooks').doc(outlookId);
          const outlookDoc = await outlookRef.get();
          const outlookData = outlookDoc.data();
          const likes = outlookData.likes || [];
          if (likes.includes(user.uid)) {
            alert('You have already liked this outlook.');
            return;
          }
          await outlookRef.update({
            likes: [...likes, user.uid]
          });
          setOutlooks(prev => prev.map(o => o.id === outlookId ? { ...o, likes: [...(o.likes || []), user.uid] } : o));
          setFilteredOutlooks(prev => prev.map(o => o.id === outlookId ? { ...o, likes: [...(o.likes || []), user.uid] } : o));
          console.log('Liked outlook:', outlookId);
        } catch (err) {
          console.error('Error liking outlook:', err);
          setError('Failed to like outlook');
        }
      };

      useEffect(() => {
        console.log('Fetching outlooks for ViewOutlookPage');
        db.collection('outlooks')
          .where('date', '>=', new Date().toISOString().split('T')[0])
          .get()
          .then(snapshot => {
            const outlooksData = snapshot.docs.map(doc => ({
              id: doc.id,
              ...doc.data(),
              createdAt: doc.data().createdAt?.toDate ? doc.data().createdAt.toDate() : new Date(doc.data().createdAt)
            }));
            console.log('Fetched future outlooks:', outlooksData);
            setOutlooks(outlooksData);
            setFilteredOutlooks(outlooksData);
            if (outlooksData.length > 0) {
              setSelectedOutlook(outlooksData[0]);
            }
          })
          .catch(err => {
            console.error('Error fetching outlooks:', err);
            setError('Failed to load outlooks');
          });
      }, []);

      useEffect(() => {
        let filtered = outlooks;
        if (dateFilter) {
          filtered = filtered.filter(outlook => outlook.date === dateFilter);
        }
        if (searchUsername) {
          filtered = filtered.filter(outlook => outlook.username.toLowerCase().includes(searchUsername.toLowerCase()));
        }
        filtered = filtered.sort((a, b) => {
          if (sortBy === 'latest') {
            return b.createdAt - a.createdAt;
          } else if (sortBy === 'mostLikes') {
            return (b.likes?.length || 0) - (a.likes?.length || 0);
          }
          return 0;
        });
        setFilteredOutlooks(filtered);
      }, [dateFilter, searchUsername, sortBy, outlooks]);

      useEffect(() => {
        waitForLeaflet(() => {
          try {
            console.log('Initializing Leaflet for ViewOutlookPage');
            const map = L.map('view-map').setView([54.5, -3], 6);
            mapRef.current = map;
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
              maxZoom: 19,
              attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
            }).addTo(map).on('tileerror', error => {
              console.error('Tile error:', error);
              setError('Failed to load map tiles');
            });
            setTimeout(() => {
              map.invalidateSize();
              console.log('Map size invalidated for ViewOutlookPage');
            }, 100);
            return () => {
              console.log('Cleaning up ViewOutlookPage map');
              map.remove();
            };
          } catch (err) {
            console.error('Error initializing ViewOutlookPage map:', err);
            setError('Failed to initialize map');
          }
        });
      }, []);

      useEffect(() => {
        if (!mapRef.current || !selectedOutlook) return;
        console.log('Updating GeoJSON for outlook:', selectedOutlook.id);
        geoJsonLayersRef.current.forEach(layer => {
          if (mapRef.current.hasLayer(layer)) {
            mapRef.current.removeLayer(layer);
          }
        });
        geoJsonLayersRef.current = [];
        if (selectedOutlook.polygons) {
          const parsedPolygons = selectedOutlook.polygons
            .map(p => {
              try {
                return {
                  ...p,
                  geometry: {
                    ...p.geometry,
                    coordinates: JSON.parse(p.geometry.coordinates)
                  },
                  properties: {
                    ...p.properties,
                    Name: p.properties.Name || 'low risk',
                    color: p.properties.color || RISK_COLORS[p.properties.Name?.toLowerCase() || 'low risk']
                  }
                };
              } catch (err) {
                console.error('Error parsing polygon:', p, err);
                return null;
              }
            }).filter(p => p !== null);
          console.log('Parsed polygons for ViewOutlookPage:', parsedPolygons.length);

          const polygonsByRisk = RISK_ORDER.reduce((acc, risk) => {
            acc[risk] = parsedPolygons.filter(p => p.properties.Name?.toLowerCase() === risk);
            return acc;
          }, {});
          console.log('Polygons by risk:', polygonsByRisk);

          RISK_ORDER.forEach(risk => {
            if (polygonsByRisk[risk].length) {
              const layer = L.geoJSON(polygonsByRisk[risk], {
                style: feature => {
                  const riskLevel = feature.properties.Name?.toLowerCase() || 'low risk';
                  const color = RISK_COLORS[riskLevel] || '#66c2a4';
                  if (!RISK_COLORS[riskLevel]) {
                    console.warn('Invalid risk level:', riskLevel, 'for polygon', feature);
                  }
                  console.log('Assigning color for', feature.properties.Name, ':', color);
                  return {
                    color,
                    fillColor: color,
                    fillOpacity: 0.4
                  };
                }
              }).addTo(mapRef.current);
              geoJsonLayersRef.current.push(layer);
              console.log('Added GeoJSON layer for', risk);
            }
          });
          setTimeout(() => {
            if (mapRef.current) {
              mapRef.current.invalidateSize();
              console.log('Map size invalidated after GeoJSON layer update');
            }
          }, 100);
        }
      }, [selectedOutlook]);

      const formatTimestamp = (timestamp) => {
        if (!timestamp) return 'Unknown';
        try {
          const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
          return date.toLocaleString('en-GB', {
            day: '2-digit',
            month: '2-digit',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            timeZone: 'Europe/London'
          });
        } catch {
          return 'Unknown';
        }
      };

      return (
        <div className="p-6 container mx-auto">
          <h1 className="text-3xl font-bold text-gray-800 mb-6">View Outlooks</h1>
          {error && <p className="text-red-500 mb-4 bg-red-100 p-3 rounded-lg">{error}</p>}
          <div className="flex flex-col md:flex-row gap-6">
            <div className="md:w-1/3 bg-white p-6 rounded-lg shadow-md">
              <div className="mb-4">
                <label className="block text-gray-700 mb-2">Filter by Date</label>
                <input
                  type="date"
                  value={dateFilter}
                  onChange={e => setDateFilter(e.target.value)}
                  min={new Date().toISOString().split('T')[0]}
                  className="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
              </div>
              <div className="mb-4">
                <label className="block text-gray-700 mb-2">Search by Username</label>
                <input
                  type="text"
                  value={searchUsername}
                  onChange={e => setSearchUsername(e.target.value)}
                  placeholder="Enter username"
                  className="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
              </div>
              <div className="mb-4">
                <label className="block text-gray-700 mb-2">Sort By</label>
                <select
                  value={sortBy}
                  onChange={e => setSortBy(e.target.value)}
                  className="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                >
                  <option value="latest">Latest Published</option>
                  <option value="mostLikes">Most Likes</option>
                </select>
              </div>
              <ul className="space-y-2 max-h-60 overflow-y-auto">
                {filteredOutlooks.map(outlook => (
                  <li
                    key={outlook.id}
                    onClick={() => setSelectedOutlook(outlook)}
                    className="cursor-pointer p-3 hover:bg-gray-100 rounded-lg"
                  >
                    {outlook.username} - {outlook.date} (Score: Pending)
                    <br />
                    Likes: {outlook.likes?.length || 0} | Published: {formatTimestamp(outlook.createdAt)}
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        handleLike(outlook.id);
                      }}
                      className="ml-2 text-blue-500 hover:text-blue-700"
                    >
                      Like
                    </button>
                  </li>
                ))}
              </ul>
            </div>
            <div className="md:w-2/3">
              <div id="view-map" className="h-[500px] w-full rounded-lg shadow-md"></div>
            </div>
          </div>
        </div>
      );
    };
    
    
    const YourUploadsPage = ({ user, username, email }) => {
  const [outlooks, setOutlooks] = useState([]);
  const [drafts, setDrafts] = useState([]);
  const [selectedOutlook, setSelectedOutlook] = useState(null);
  const [selectedDraftId, setSelectedDraftId] = useState('');
  const [error, setError] = useState(null);
  const [drawnItems, setDrawnItems] = useState([]);
  const [riskLevel, setRiskLevel] = useState('low risk');
  const [severeConditions, setSevereConditions] = useState({
    rainfall: false,
    hail: false,
    tornado: false,
    gusts: false
  });
  const [selectedPolygonId, setSelectedPolygonId] = useState(null);
  const [sizeError, setSizeError] = useState(null);
  const [forecastDate, setForecastDate] = useState('');
  const [lightningStrikes, setLightningStrikes] = useState([]);
  const [severeReports, setSevereReports] = useState([]);
  const [showLightning, setShowLightning] = useState(true);
  const [showSevereReports, setShowSevereReports] = useState(true);
  const [showPast, setShowPast] = useState(false);
  const mapRef = useRef(null);
  const drawRef = useRef(null);

  const validatePolygonSizes = (polygons) => {
    for (let i = 0; i < polygons.length; i++) {
      const poly1 = polygons[i];
      if (!poly1.geometry || !poly1.geometry.coordinates || !poly1.properties.Name) {
        return `Error: Invalid polygon data at index ${i}`;
      }
      if (poly1.properties.Name.toLowerCase() === 'severe risk') continue;
      try {
        const area1 = turf.area(turf.polygon(poly1.geometry.coordinates));
        const riskIndex1 = RISK_ORDER.indexOf(poly1.properties.Name.toLowerCase());
        for (let k = i + 1; k < polygons.length; k++) {
          const poly2 = polygons[k];
          if (!poly2.geometry || !poly2.geometry.coordinates) {
            return `Error: Invalid polygon data at index ${k}`;
          }
          if (poly2.properties.Name.toLowerCase() === 'severe risk') continue;
          const area2 = turf.area(turf.polygon(poly2.geometry.coordinates));
          const riskIndex2 = RISK_ORDER.indexOf(poly2.properties.Name.toLowerCase());
          if (riskIndex1 > riskIndex2 && area1 > area2) {
            return `Error: ${poly1.properties.Name} area must be smaller than ${poly2.properties.Name} area.`;
          }
          if (riskIndex2 > riskIndex1 && area2 > area1) {
            return `Error: ${poly2.properties.Name} area must be smaller than ${poly1.properties.Name} area.`;
          }
        }
      } catch (err) {
        console.error('Error in validatePolygonSizes:', err);
        return `Error validating polygon sizes: ${err.message}`;
      }
    }
    return null;
  };

  const updateDrawnFeatures = () => {
    console.log('Updating drawn features');
    const features = drawRef.current.getAll().features;
    features.forEach(feature => {
      if (!feature.properties?.Name) {
        feature.properties = {
          Name: riskLevel,
          color: RISK_COLORS[riskLevel],
          severeConditions: riskLevel === 'severe risk' ? severeConditions : {}
        };
        console.log('Set properties for feature', feature.id, ':', feature.properties);
      }
    });
    features.sort((a, b) => RISK_ORDER.indexOf(b.properties.Name.toLowerCase()) - RISK_ORDER.indexOf(a.properties.Name.toLowerCase()));
    setDrawnItems(features);
    if (mapRef.current.getSource('drawnFeatures')) {
      mapRef.current.getSource('drawnFeatures').setData({
        type: 'FeatureCollection',
        features: features
      });
      console.log('Updated map source with features');
    }
  };

  useEffect(() => {
    waitForMapbox(() => {
      try {
        // Check if the container exists before initializing the map
        const mapContainer = document.getElementById('Uploads-map');
        if (!mapContainer) {
          console.error('Map container "Uploads-map" not found in DOM');
          setError('Map container not found. Please try refreshing the page.');
          return;
        }

        mapboxgl.accessToken = 'pk.eyJ1IjoiaGFuZHJ5MjAxOTEwMjYiLCJhIjoiY21jYWg2eG1lMDNkYTJxczVyOWM5bW9mciJ9.bA-qxiByTB_RseY1fgU4rg';
        
        const map = new mapboxgl.Map({
          container: 'Uploads-map',
          style: 'mapbox://styles/mapbox/streets-v11',
          center: [-3, 54.5],
          zoom: 6,
          minZoom: 3,
          maxZoom: 10,
          maxBounds: [[UK_BBOX[0], UK_BBOX[1]], [UK_BBOX[2], UK_BBOX[3]]]
        });
        mapRef.current = map;

        map.on('load', () => {
          map.resize();
          console.log('Map resized after load');
        });

        const draw = new MapboxDraw({
          displayControlsDefault: false,
          controls: {
            polygon: true,
            trash: true
          },
          defaultMode: 'draw_polygon',
          styles: [
            {
              id: 'gl-draw-polygon-fill-inactive',
              type: 'fill',
              filter: ['all', ['==', 'active', 'false'], ['==', '$type', 'Polygon']],
              paint: {
                'fill-color': ['get', 'color'],
                'fill-opacity': ['case', ['==', ['get', 'Name'], 'severe risk'], 0, 0.4]
              }
            },
            {
              id: 'gl-draw-polygon-stroke-inactive',
              type: 'line',
              filter: ['all', ['==', 'active', 'false'], ['==', '$type', 'Polygon']],
              paint: {
                'line-color': ['get', 'color'],
                'line-width': 2
              }
            },
            {
              id: 'gl-draw-polygon-fill-active',
              type: 'fill',
              filter: ['all', ['==', 'active', 'true'], ['==', '$type', 'Polygon']],
              paint: {
                'fill-color': ['get', 'color'],
                'fill-opacity': ['case', ['==', ['get', 'Name'], 'severe risk'], 0, 0.4]
              }
            },
            {
              id: 'gl-draw-polygon-stroke-active',
              type: 'line',
              filter: ['all', ['==', 'active', 'true'], ['==', '$type', 'Polygon']],
              paint: {
                'line-color': ['get', 'color'],
                'line-width': 3
              }
            },
            {
              id: 'gl-draw-polygon-midpoint',
              type: 'circle',
              filter: ['all', ['==', '$type', 'Point'], ['==', 'meta', 'midpoint']],
              paint: {
                'circle-radius': 3,
                'circle-color': '#fbb03b'
              }
            },
            {
              id: 'gl-draw-polygon-vertex-inactive',
              type: 'circle',
              filter: ['all', ['==', 'meta', 'vertex'], ['==', '$type', 'Point'], ['!=', 'mode', 'static']],
              paint: {
                'circle-radius': 5,
                'circle-color': '#fff'
              }
            }
          ]
        });
        map.addControl(draw);
        drawRef.current = draw;

        map.on('draw.create', (e) => {
          console.log('Draw create event:', e);
          const feature = e.features[0];
          feature.properties = {
            Name: riskLevel,
            color: RISK_COLORS[riskLevel],
            severeConditions: riskLevel === 'severe risk' ? severeConditions : {}
          };
          console.log('Created feature', feature.id, 'with properties:', feature.properties);
          const newItems = [...drawnItems, feature];
          const validationError = validatePolygonSizes(newItems);
          if (validationError) {
            setSizeError(validationError);
            draw.delete(feature.id);
          } else {
            setSizeError(null);
            setDrawnItems(newItems);
            setSelectedPolygonId(feature.id);
          }
          updateDrawnFeatures();
        });

        map.on('draw.update', updateDrawnFeatures);
        map.on('draw.delete', () => {
          updateDrawnFeatures();
          setSelectedPolygonId(null);
        });

        map.on('draw.selectionchange', (e) => {
          const selected = e.features[0]?.id;
          setSelectedPolygonId(selected || null);
          if (selected) {
            const feature = drawRef.current.get(selected);
            if (feature) {
              setRiskLevel(feature.properties.Name);
              if (feature.properties.Name === 'severe risk') {
                setSevereConditions(feature.properties.severeConditions || {
                  rainfall: false,
                  hail: false,
                  tornado: false,
                  gusts: false
                });
              } else {
                setSevereConditions({
                  rainfall: false,
                  hail: false,
                  tornado: false,
                  gusts: false
                });
              }
              drawRef.current.changeMode('direct_select', { featureId: selected });
            }
          }
        });

        map.on('draw.modechange', (e) => {
          console.log('Mode changed to:', e.mode);
          if (e.mode === 'simple_select' && selectedPolygonId) {
            drawRef.current.changeMode('direct_select', { featureId: selectedPolygonId });
          }
        });

        map.on('load', () => {
          map.addSource('drawnFeatures', {
            type: 'geojson',
            data: { type: 'FeatureCollection', features: [] }
          });
          map.addSource('lightning', {
            type: 'geojson',
            data: { type: 'FeatureCollection', features: [] }
          });
          map.addSource('severe-reports', {
            type: 'geojson',
            data: { type: 'FeatureCollection', features: [] }
          });

          map.addLayer({
            id: 'drawnPolygons',
            type: 'fill',
            source: 'drawnFeatures',
            filter: ['!=', 'Name', 'severe risk'],
            paint: {
              'fill-color': ['get', 'color'],
              'fill-opacity': [
                'interpolate',
                ['linear'],
                ['zoom'],
                3, 0.2,
                10, 0.4
              ]
            }
          });
          map.addLayer({
            id: 'drawnPolygonsOutline',
            type: 'line',
            source: 'drawnFeatures',
            paint: {
              'line-color': ['case', ['==', ['get', 'Name'], 'severe risk'], '#000000', ['get', 'color']],
              'line-width': 2
            }
          });
          map.addLayer({
            id: 'drawnSeverePolygons',
            type: 'fill',
            source: 'drawnFeatures',
            filter: ['==', 'Name', 'severe risk'],
            paint: {
              'fill-opacity': 0
            }
          });
          map.addLayer({
            id: 'lightning-points',
            type: 'circle',
            source: 'lightning',
            paint: {
              'circle-radius': 5,
              'circle-color': '#ff0',
              'circle-opacity': 0.8
            }
          });
          map.addLayer({
            id: 'severe-reports-points',
            type: 'circle',
            source: 'severe-reports',
            paint: {
              'circle-radius': 5,
              'circle-color': '#f00',
              'circle-opacity': 0.8
            }
          });
        });

        const fetchData = async () => {
          try {
            const outlookSnapshot = await db.collection('outlooks')
              .where('email', '==', email)
              .get();
            const outlooksData = outlookSnapshot.docs.map(doc => ({
              id: doc.id,
              ...doc.data(),
              createdAt: doc.data().createdAt?.toDate ? doc.data().createdAt.toDate() : new Date(doc.data().createdAt)
            }));
            setOutlooks(outlooksData);

            const draftSnapshot = await db.collection('drafts')
              .where('email', '==', email)
              .get();
            const draftsData = draftSnapshot.docs.map(doc => ({
              id: doc.id,
              ...doc.data(),
              createdAt: doc.data().createdAt?.toDate ? doc.data().createdAt.toDate() : new Date(doc.data().createdAt)
            }));
            setDrafts(draftsData);
          } catch (err) {
            console.error('Error fetching data:', err);
            setError('Failed to load your uploads');
          }
        };
        fetchData();

        return () => {
          if (mapRef.current) {
            mapRef.current.remove();
            mapRef.current = null;
          }
        };
      } catch (err) {
        console.error('Error initializing map:', err);
        setError('Failed to initialize map: ' + err.message);
      }
    });
  }, [email]);

  useEffect(() => {
    if (!mapRef.current || !selectedOutlook) return;
    const map = mapRef.current;
    if (map.getSource('drawnFeatures')) {
      map.getSource('drawnFeatures').setData({
        type: 'FeatureCollection',
        features: drawnItems
      });
    }
  }, [drawnItems, selectedOutlook]);

  useEffect(() => {
    if (!mapRef.current || !selectedOutlook || !selectedOutlook.date) {
      setSevereReports([]);
      setLightningStrikes([]);
      if (mapRef.current) {
        if (mapRef.current.getSource('severe-reports')) {
          mapRef.current.getSource('severe-reports').setData({
            type: 'FeatureCollection',
            features: []
          });
          mapRef.current.setLayoutProperty('severe-reports-points', 'visibility', 'none');
        }
        if (mapRef.current.getSource('lightning')) {
          mapRef.current.getSource('lightning').setData({
            type: 'FeatureCollection',
            features: []
          });
          mapRef.current.setLayoutProperty('lightning-points', 'visibility', 'none');
        }
      }
      return;
    }

    // Toggle Mapbox Draw controls based on showPast
    if (drawRef.current) {
      if (showPast) {
        drawRef.current.options.controls.polygon = false;
        drawRef.current.options.controls.trash = false;
        drawRef.current.changeMode('simple_select');
      } else {
        drawRef.current.options.controls.polygon = true;
        drawRef.current.options.controls.trash = true;
        drawRef.current.changeMode('draw_polygon');
      }
    }

    const fetchSevereReports = async () => {
      try {
        const snapshot = await db.collection('severe_reports')
          .where('date', '==', selectedOutlook.date)
          .get();

        const reports = snapshot.docs.map(doc => {
          const data = doc.data();
          return {
            id: doc.id,
            ...data,
            createdAt: data.createdAt?.toDate ? data.createdAt.toDate() : new Date(data.createdAt || Date.now()),
            observedAt: data.observedAt ? new Date(data.observedAt) : null,
            location: data.location && Array.isArray(data.location) && data.location.length === 2 ? data.location : null
          };
        });

        console.log('Fetched severe reports:', reports);
        setSevereReports(reports);

        if (mapRef.current.getSource('severe-reports')) {
          const validReports = reports.filter(r => r.location && Array.isArray(r.location) && r.location.length === 2);
          mapRef.current.getSource('severe-reports').setData({
            type: 'FeatureCollection',
            features: validReports.map(r => ({
              type: 'Feature',
              geometry: {
                type: 'Point',
                coordinates: r.location
              },
              properties: {
                condition: r.condition || 'Unknown',
                createdBy: r.createdBy || 'Unknown',
                createdAt: r.createdAt,
                observedAt: r.observedAt
              }
            }))
          });
          mapRef.current.setLayoutProperty(
            'severe-reports-points',
            'visibility',
            showPast && showSevereReports ? 'visible' : 'none'
          );
        }
      } catch (err) {
        console.error('Error fetching severe reports:', err.message, err.code);
        setError(`Failed to load severe reports: ${err.message}`);
      }
    };

    if (showPast) {
      fetchLightningData(selectedOutlook.date, setError).then(strikes => {
        setLightningStrikes(strikes);
        if (mapRef.current.getSource('lightning')) {
          mapRef.current.getSource('lightning').setData({
            type: 'FeatureCollection',
            features: strikes.map(s => ({
              type: 'Feature',
              geometry: {
                type: 'Point',
                coordinates: s.coordinates
              }
            }))
          });
          mapRef.current.setLayoutProperty(
            'lightning-points',
            'visibility',
            showLightning ? 'visible' : 'none'
          );
        }
      });
      fetchSevereReports();
    } else {
      setLightningStrikes([]);
      if (mapRef.current.getSource('lightning')) {
        mapRef.current.getSource('lightning').setData({
          type: 'FeatureCollection',
          features: []
        });
        mapRef.current.setLayoutProperty('lightning-points', 'visibility', 'none');
      }
      setSevereReports([]);
      if (mapRef.current.getSource('severe-reports')) {
        mapRef.current.getSource('severe-reports').setData({
          type: 'FeatureCollection',
          features: []
        });
        mapRef.current.setLayoutProperty('severe-reports-points', 'visibility', 'none');
      }
    }
  }, [selectedOutlook, showLightning, showSevereReports, showPast]);

  const loadDraft = async (draftId) => {
    const draft = drafts.find(d => d.id === draftId);
    if (!draft) return;
    setSelectedDraftId(draftId);
    setForecastDate(draft.date);
    const parsedPolygons = draft.polygons.map(p => ({
      ...p,
      geometry: {
        ...p.geometry,
        coordinates: JSON.parse(p.geometry.coordinates)
      }
    }));
    setDrawnItems(parsedPolygons);
    drawRef.current.deleteAll();
    parsedPolygons.forEach(feature => {
      drawRef.current.add(feature);
    });
    setSelectedPolygonId(null);
    setRiskLevel('low risk');
    setSevereConditions({
      rainfall: false,
      hail: false,
      tornado: false,
      gusts: false
    });
  };

  const deleteDraft = async (draftId) => {
    try {
      await db.collection('drafts').doc(draftId).delete();
      setDrafts(drafts.filter(d => d.id !== draftId));
      if (selectedDraftId === draftId) {
        setSelectedDraftId('');
        drawRef.current.deleteAll();
        setDrawnItems([]);
        setForecastDate('');
      }
      alert('Draft deleted successfully');
    } catch (err) {
      console.error('Error deleting draft:', err);
      setError('Failed to delete draft');
    }
  };

  const submitDraft = async () => {
    if (drawnItems.length === 0) {
      alert('Please draw at least one polygon before submitting.');
      return;
    }
    if (!forecastDate) {
      alert('Please select a forecast date.');
      return;
    }
    const validationError = validatePolygonSizes(drawnItems);
    if (validationError) {
      alert(`Validation error: ${validationError}`);
      return;
    }
    try {
      const serializedPolygons = drawnItems.map(polygon => ({
        ...polygon,
        geometry: {
          ...polygon.geometry,
          coordinates: JSON.stringify(polygon.geometry.coordinates)
        },
        properties: {
          ...polygon.properties,
          Name: polygon.properties.Name,
          color: RISK_COLORS[polygon.properties.Name.toLowerCase()]
        }
      }));
      const version = await getNextVersion('outlooks', email, forecastDate);
      await db.collection('outlooks').add({
        username,
        email,
        polygons: serializedPolygons,
        date: forecastDate,
        severeConditions: drawnItems.some(item => item.properties.Name === 'severe risk') ? severeConditions : {},
        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
        score: null,
        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
        version,
        likes: []
      });
      if (selectedDraftId) {
        await db.collection('drafts').doc(selectedDraftId).delete();
        setDrafts(drafts.filter(d => d.id !== selectedDraftId));
        setSelectedDraftId('');
      }
      setDrawnItems([]);
      setSelectedPolygonId(null);
      drawRef.current.deleteAll();
      const outlookSnapshot = await db.collection('outlooks').where('email', '==', email).get();
      setOutlooks(outlookSnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        createdAt: doc.data().createdAt?.toDate ? doc.data().createdAt.toDate() : new Date(doc.data().createdAt)
      })));
      alert('Draft submitted successfully!');
    } catch (err) {
      console.error('Error submitting draft:', err);
      setError('Failed to submit draft');
    }
  };

  const updateOutlook = async () => {
    if (!selectedOutlook || drawnItems.length === 0) {
      alert('Please draw at least one polygon to update the forecast.');
      return;
    }
    const validationError = validatePolygonSizes(drawnItems);
    if (validationError) {
      alert(`Validation error: ${validationError}`);
      return;
    }
    try {
      const serializedPolygons = drawnItems.map(polygon => ({
        ...polygon,
        geometry: {
          ...polygon.geometry,
          coordinates: JSON.stringify(polygon.geometry.coordinates)
        },
        properties: {
          ...polygon.properties,
          Name: polygon.properties.Name,
          color: RISK_COLORS[polygon.properties.Name.toLowerCase()]
        }
      }));
      await db.collection('outlooks').doc(selectedOutlook.id).update({
        polygons: serializedPolygons,
        severeConditions: drawnItems.some(item => item.properties.Name === 'severe risk') ? severeConditions : {},
        timestamp: firebase.firestore.FieldValue.serverTimestamp()
      });
      setDrawnItems([]);
      setSelectedPolygonId(null);
      drawRef.current.deleteAll();
      const outlookSnapshot = await db.collection('outlooks').where('email', '==', email).get();
      setOutlooks(outlookSnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        createdAt: doc.data().createdAt?.toDate ? doc.data().createdAt.toDate() : new Date(doc.data().createdAt)
      })));
      setSelectedOutlook(null);
      alert('Forecast updated successfully!');
    } catch (err) {
      console.error('Error updating outlook:', err);
      setError('Failed to update forecast');
    }
  };

  const updateRiskLevel = (newRiskLevel) => {
    console.log('Updating risk level to:', newRiskLevel);
    setRiskLevel(newRiskLevel);
    if (selectedPolygonId) {
      const feature = drawRef.current.get(selectedPolygonId);
      if (feature) {
        drawRef.current.setFeatureProperty(selectedPolygonId, 'Name', newRiskLevel);
        drawRef.current.setFeatureProperty(selectedPolygonId, 'color', RISK_COLORS[newRiskLevel]);
        drawRef.current.setFeatureProperty(selectedPolygonId, 'severeConditions', newRiskLevel === 'severe risk' ? severeConditions : {});
        console.log('Updated feature', selectedPolygonId, 'to', newRiskLevel);
        updateDrawnFeatures();
      }
    }
  };

  const updateSevereConditions = (newConditions) => {
    console.log('Updating severe conditions:', newConditions);
    setSevereConditions(newConditions);
    if (selectedPolygonId && riskLevel === 'severe risk') {
      drawRef.current.setFeatureProperty(selectedPolygonId, 'severeConditions', newConditions);
      console.log('Updated severe conditions for feature', selectedPolygonId);
      updateDrawnFeatures();
    }
  };

  const handleSevereChange = (e) => {
    console.log('Handling severe change:', e.target.name, e.target.checked);
    const newConditions = {
      ...severeConditions,
      [e.target.name]: e.target.checked
    };
    updateSevereConditions(newConditions);
  };

  const clearPolygons = () => {
    console.log('Clearing polygons');
    setDrawnItems([]);
    setSelectedPolygonId(null);
    setSelectedDraftId('');
    setForecastDate('');
    setRiskLevel('low risk');
    setSevereConditions({
      rainfall: false,
      hail: false,
      tornado: false,
      gusts: false
    });
    drawRef.current.deleteAll();
    setSizeError(null);
    if (mapRef.current.getSource('drawnFeatures')) {
      mapRef.current.getSource('drawnFeatures').setData({
        type: 'FeatureCollection',
        features: []
      });
      console.log('Cleared map source');
    }
  };

  const formatTimestamp = (timestamp) => {
    if (!timestamp) return 'Unknown';
    try {
      const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
      return date.toLocaleString('en-GB', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        timeZone: 'Europe/London'
      });
    } catch {
      return 'Unknown';
    }
  };

  const currentDate = new Date().toISOString().split('T')[0];
  const displayedOutlooks = showPast
    ? outlooks.filter(outlook => outlook.date < currentDate)
    : outlooks.filter(outlook => outlook.date >= currentDate);

  return (
    <div className="p-6 container mx-auto">
      <h1 className="text-3xl font-bold text-gray-800 mb-6">Your Uploads</h1>
      {error && <p className="text-red-500 mb-4 bg-red-100 p-3 rounded-lg">{error}</p>}
      {sizeError && <p className="text-red-500 mb-4 bg-red-100 p-3 rounded-lg">{sizeError}</p>}
      <div className="flex flex-col md:flex-row gap-6">
        <div className="md:w-1/3 bg-white p-6 rounded-lg shadow-md">
          <button
            onClick={() => setShowPast(!showPast)}
            className="mb-4 bg-gray-600 text-white p-2 rounded-lg hover:bg-gray-700 transition"
          >
            {showPast ? 'Show Future Forecasts' : 'Show Past Forecasts'}
          </button>
          <h2 className="text-xl font-semibold text-gray-700 mb-4">
            {showPast ? 'Past Forecasts' : 'Future Forecasts'}
          </h2>
          <ul className="space-y-2 mb-4 max-h-60 overflow-y-auto">
            {displayedOutlooks.map(outlook => (
              <li
                key={outlook.id}
                onClick={() => {
                  setSelectedOutlook(outlook);
                  setSelectedDraftId('');
                  drawRef.current.deleteAll();
                  setDrawnItems([]);
                  setForecastDate(outlook.date);
                  try {
                    const parsedPolygons = outlook.polygons.map(p => ({
                      ...p,
                      geometry: {
                        ...p.geometry,
                        coordinates: JSON.parse(p.geometry.coordinates)
                      }
                    }));
                    drawRef.current.deleteAll();
                    parsedPolygons.forEach(feature => {
                      drawRef.current.add(feature);
                    });
                    setDrawnItems(parsedPolygons);
                    setSelectedPolygonId(null);
                    setRiskLevel('low risk');
                    setSevereConditions({
                      rainfall: false,
                      hail: false,
                      tornado: false,
                      gusts: false
                    });
                  } catch (err) {
                    console.error('Error loading polygons for outlook:', outlook.id, err);
                    setError('Failed to load polygons for the selected forecast');
                  }
                }}
                className="cursor-pointer p-3 hover:bg-gray-100 rounded-lg"
              >
                {outlook.date} {outlook.version} (Score: {outlook.score != null ? outlook.score.toFixed(2) : 'Pending'})
                <br />
                Published: {formatTimestamp(outlook.createdAt)}
              </li>
            ))}
          </ul>
          <h2 className="text-xl font-semibold text-gray-700 mb-4">Your Drafts</h2>
          <select
            value={selectedDraftId}
            onChange={e => loadDraft(e.target.value)}
            className="w-full p-2 mb-4 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            <option value="">Select a Draft</option>
            {drafts.map(draft => (
              <option key={draft.id} value={draft.id}>{draft.name} ({draft.date})</option>
            ))}
          </select>
          {selectedDraftId && (
            <>
              <h2 className="text-xl font-semibold text-gray-700 mb-4">Edit Draft</h2>
              <input
                type="date"
                value={forecastDate}
                onChange={e => setForecastDate(e.target.value)}
                min={email === 'admin@example.com' ? undefined : new Date().toISOString().split('T')[0]}
                className="w-full p-2 mb-4 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
              <h2 className="text-xl font-semibold text-gray-700 mb-4">Risk Level</h2>
              <select
                value={riskLevel}
                onChange={e => updateRiskLevel(e.target.value)}
                className="w-full p-2 mb-4 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                {RISK_ORDER.map(risk => (
                  <option key={risk} value={risk}>{risk.charAt(0).toUpperCase() + risk.slice(1)}</option>
                ))}
              </select>
              {riskLevel === 'severe risk' && selectedPolygonId && (
                <>
                  <h2 className="text-xl font-semibold text-gray-700 mb-4">Severe Conditions</h2>
                  {['rainfall', 'hail', 'tornado', 'gusts'].map(condition => (
                    <label key={condition} className="flex items-center mb-2">
                      <input
                        type="checkbox"
                        name={condition}
                        checked={severeConditions[condition]}
                        onChange={handleSevereChange}
                        className="mr-2 h-5 w-5 text-blue-600"
                      />
                      <span className="text-gray-600">
                        {condition.charAt(0).toUpperCase() + condition.slice(1)}
                        {condition === 'rainfall' && ' (>25mm/3hr)'}
                        {condition === 'hail' && ' (>2cm)'}
                        {condition === 'tornado' && ''}
                        {condition === 'gusts' && ' (>55mph)'}
                      </span>
                    </label>
                  ))}
                </>
              )}
              <h2 className="text-xl font-semibold text-gray-700 mb-4">Drawn Polygons</h2>
              <ul className="space-y-2 mb-4 max-h-60 overflow-y-auto">
                {drawnItems.map(item => (
                  <li
                    key={item.id}
                    className={`p-2 cursor-pointer rounded-lg ${selectedPolygonId === item.id ? 'bg-blue-100' : 'hover:bg-gray-100'}`}
                    onClick={() => {
                      setSelectedPolygonId(item.id);
                      setRiskLevel(item.properties.Name);
                      setSevereConditions(item.properties.severeConditions || {
                        rainfall: false,
                        hail: false,
                        tornado: false,
                        gusts: false
                      });
                      drawRef.current.changeMode('direct_select', { featureId: item.id });
                    }}
                  >
                    {item.properties.Name} (ID: {item.id.slice(0, 8)})
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        drawRef.current.delete(item.id);
                        setDrawnItems(drawnItems.filter(i => i.id !== item.id));
                        setSelectedPolygonId(null);
                      }}
                      className="ml-2 text-red-500 hover:text-red-700"
                    >
                      Delete
                    </button>
                  </li>
                ))}
              </ul>
              <div className="flex space-x-4">
                <button
                  onClick={submitDraft}
                  className="bg-blue-600 text-white p-3 rounded-lg hover:bg-blue-700 transition disabled:bg-blue-400"
                  disabled={sizeError}
                >
                  Submit Draft
                </button>
                <button
                  onClick={() => deleteDraft(selectedDraftId)}
                  className="bg-red-600 text-white p-3 rounded-lg hover:bg-red-700 transition"
                >
                  Delete Draft
                </button>
                <button
                  onClick={clearPolygons}
                  className="bg-red-600 text-white p-3 rounded-lg hover:bg-red-700 transition"
                >
                  Clear Polygons
                </button>
              </div>
            </>
          )}
          {selectedOutlook && !showPast && selectedOutlook.date >= new Date().toISOString().split('T')[0] && (
            <>
              <h2 className="text-xl font-semibold text-gray-700 mt-4 mb-4">Edit Forecast</h2>
              <input
                type="date"
                value={forecastDate}
                onChange={e => setForecastDate(e.target.value)}
                min={email === 'admin@example.com' ? undefined : new Date().toISOString().split('T')[0]}
                className="w-full p-2 mb-4 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
              <h2 className="text-xl font-semibold text-gray-700 mb-4">Risk Level</h2>
              <select
                value={riskLevel}
                onChange={e => updateRiskLevel(e.target.value)}
                className="w-full p-2 mb-4 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                {RISK_ORDER.map(risk => (
                  <option key={risk} value={risk}>{risk.charAt(0).toUpperCase() + risk.slice(1)}</option>
                ))}
              </select>
              {riskLevel === 'severe risk' && selectedPolygonId && (
                <>
                  <h2 className="text-xl font-semibold text-gray-700 mb-4">Severe Conditions</h2>
                  {['rainfall', 'hail', 'tornado', 'gusts'].map(condition => (
                    <label key={condition} className="flex items-center mb-2">
                      <input
                        type="checkbox"
                        name={condition}
                        checked={severeConditions[condition]}
                        onChange={handleSevereChange}
                        className="mr-2 h-5 w-5 text-blue-600"
                      />
                      <span className="text-gray-600">
                        {condition.charAt(0).toUpperCase() + condition.slice(1)}
                        {condition === 'rainfall' && ' (>25mm/3hr)'}
                        {condition === 'hail' && ' (>2cm)'}
                        {condition === 'tornado' && ''}
                        {condition === 'gusts' && ' (>55mph)'}
                      </span>
                    </label>
                  ))}
                </>
              )}
              <h2 className="text-xl font-semibold text-gray-700 mb-4">Drawn Polygons</h2>
              <ul className="space-y-2 mb-4 max-h-60 overflow-y-auto">
                {drawnItems.map(item => (
                  <li
                    key={item.id}
                    className={`p-2 cursor-pointer rounded-lg ${selectedPolygonId === item.id ? 'bg-blue-100' : 'hover:bg-gray-100'}`}
                    onClick={() => {
                      setSelectedPolygonId(item.id);
                      setRiskLevel(item.properties.Name);
                      setSevereConditions(item.properties.severeConditions || {
                        rainfall: false,
                        hail: false,
                        tornado: false,
                        gusts: false
                      });
                      drawRef.current.changeMode('direct_select', { featureId: item.id });
                    }}
                  >
                    {item.properties.Name} (ID: {item.id.slice(0, 8)})
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        drawRef.current.delete(item.id);
                        setDrawnItems(drawnItems.filter(i => i.id !== item.id));
                        setSelectedPolygonId(null);
                      }}
                      className="ml-2 text-red-500 hover:text-red-700"
                    >
                      Delete
                    </button>
                  </li>
                ))}
              </ul>
              <div className="flex space-x-4">
                <button
                  onClick={updateOutlook}
                  className="bg-green-600 text-white p-3 rounded-lg hover:bg-green-700 transition disabled:bg-green-400"
                  disabled={sizeError}
                >
                  Update Forecast
                </button>
                <button
                  onClick={clearPolygons}
                  className="bg-red-600 text-white p-3 rounded-lg hover:bg-red-700 transition"
                >
                  Clear Polygons
                </button>
              </div>
            </>
          )}
          {showPast && (
            <div className="mt-4">
              <button
                onClick={() => setShowLightning(!showLightning)}
                className="bg-yellow-500 text-white p-2 rounded-lg hover:bg-yellow-600 transition mr-2"
              >
                {showLightning ? 'Hide Lightning' : 'Show Lightning'}
              </button>
              <button
                onClick={() => setShowSevereReports(!showSevereReports)}
                className="bg-red-500 text-white p-2 rounded-lg hover:bg-red-600 transition"
              >
                {showSevereReports ? 'Hide Severe Reports' : 'Show Severe Reports'}
              </button>
            </div>
          )}
          {showPast && severeReports.length > 0 && (
            <div className="mt-4">
              <h2 className="text-xl font-semibold text-gray-700 mb-4">Severe Weather Reports</h2>
              <ul className="space-y-2 max-h-60 overflow-y-auto">
                {severeReports.map(report => (
                  <li key={report.id} className="p-3 bg-gray-100 rounded-lg">
                    {report.date} - {report.condition} at [{report.location ? report.location[1].toFixed(4) : 'N/A'}, {report.location ? report.location[0].toFixed(4) : 'N/A'}]
                    <br />
                    Created By: {report.createdBy || 'Unknown'}
                    <br />
                    Created: {formatTimestamp(report.createdAt)}
                    <br />
                    Observed: {report.observedAt ? report.observedAt.toLocaleString('en-GB') : 'Unknown'}
                  </li>
                ))}
              </ul>
            </div>
          )}
        </div>
        <div className="md:w-2/3">
          <div id="Uploads-map" className="h-[700px] w-full rounded-lg shadow-md"></div>
        </div>
      </div>
    </div>
  );
};
    const AccountPage = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [username, setUsername] = useState('');
  const [error, setError] = useState(null);
  const [isRegistering, setIsRegistering] = useState(false);
  const history = useHistory();

  const handleAuth = async (e) => {
    e.preventDefault();
    setError(null);
    try {
      if (isRegistering) {
        const userCredential = await auth.createUserWithEmailAndPassword(email, password);
        await db.collection('users').doc(userCredential.user.uid).set({
          username: username || email.split('@')[0],
          email,
          createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        console.log('User registered:', email);
      } else {
        await auth.signInWithEmailAndPassword(email, password);
        console.log('User logged in:', email);
      }
      history.push('/');
    } catch (err) {
      console.error('Authentication error:', err);
      setError(err.message);
    }
  };

  return (
    <div className="p-6 container mx-auto max-w-md">
      <h1 className="text-3xl font-bold text-gray-800 mb-6">{isRegistering ? 'Register' : 'Login/ Join alpha test from https://forms.gle/QaFngRHgiGXTZd6E9'}</h1>
      {error && <p className="text-red-500 mb-4 bg-red-100 p-3 rounded-lg">{error}</p>}
      <div className="bg-white p-6 rounded-lg shadow-md">
        {isRegistering && (
          <div className="mb-4">
            <label className="block text-gray-700 mb-2">Username</label>
            <input
              type="text"
              value={username}
              onChange={e => setUsername(e.target.value)}
              placeholder="Enter username"
              className="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>
        )}
        <div className="mb-4">
          <label className="block text-gray-700 mb-2">Email</label>
          <input
            type="email"
            value={email}
            onChange={e => setEmail(e.target.value)}
            placeholder="Enter email"
            className="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
        </div>
        <div className="mb-4">
          <label className="block text-gray-700 mb-2">Password</label>
          <input
            type="password"
            value={password}
            onChange={e => setPassword(e.target.value)}
            placeholder="Enter password"
            className="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
        </div>
        <button
          onClick={handleAuth}
          className="w-full bg-blue-600 text-white p-3 rounded-lg hover:bg-blue-700 transition"
        >
          {isRegistering ? 'Register' : 'Login'}
        </button>
        
      </div>
    </div>
  );
};

const AdminPage = ({ user }) => {
  const [severeReports, setSevereReports] = useState([]);
  const [date, setDate] = useState('');
  const [observedTime, setObservedTime] = useState('');
  const [condition, setCondition] = useState('Rainfall');
  const [lat, setLat] = useState('');
  const [lon, setLon] = useState('');
  const [error, setError] = useState(null);
  const mapRef = useRef(null);
  const markerRef = useRef(null);

  useEffect(() => {
    console.log('User prop:', user); // Debug user object
    waitForLeaflet(() => {
      try {
        const map = L.map('admin-map').setView([54.5, -3], 6);
        mapRef.current = map;
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 19,
          attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
        }).addTo(map);
        map.on('click', (e) => {
          setLat(e.latlng.lat.toFixed(4));
          setLon(e.latlng.lng.toFixed(4));
          if (markerRef.current) {
            map.removeLayer(markerRef.current);
          }
          markerRef.current = L.marker([e.latlng.lat, e.latlng.lng]).addTo(map);
        });
        return () => {
          map.remove();
        };
      } catch (err) {
        console.error('Error initializing AdminPage map:', err);
        setError('Failed to initialize map');
      }
    });

    db.collection('severe_reports')
      .get()
      .then((snapshot) => {
        const reports = snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }));
        setSevereReports(reports);
      })
      .catch((err) => {
        console.error('Error fetching severe reports:', err);
        setError('Failed to load severe reports');
      });
  }, [user]);

  const addSevereReport = async () => {
  if (!date || !observedTime || !lat || !lon || !condition) {
    setError('Please fill in all fields');
    return;
  }
  if (!user) {
    setError('You must be logged in to add a severe report');
    return;
  }
  try {
    const observedAt = new Date(`${date}T${observedTime}:00Z`).toISOString();
    const createdBy = user.uid; // Use UID for consistency
    await db.collection('severe_reports').add({
      date,
      condition,
      location: [parseFloat(lon), parseFloat(lat)],
      createdBy,
      createdAt: firebase.firestore.FieldValue.serverTimestamp(),
      observedAt,
    });
    setSevereReports([
      ...severeReports,
      {
        date,
        condition,
        location: [parseFloat(lon), parseFloat(lat)],
        createdBy: user.email || user.displayName || user.uid, // Display email or username in UI
        createdAt: new Date(),
        observedAt,
      },
    ]);
    setDate('');
    setObservedTime('');
    setLat('');
    setLon('');
    setCondition('Rainfall');
    if (markerRef.current) {
      mapRef.current.removeLayer(markerRef.current);
      markerRef.current = null;
    }
    alert('Severe report added successfully');
  } catch (err) {
    console.error('Error adding severe report:', err);
    setError('Failed to add severe report');
  }
};

  const deleteSevereReport = async (reportId) => {
    try {
      await db.collection('severe_reports').doc(reportId).delete();
      setSevereReports(severeReports.filter((r) => r.id !== reportId));
      alert('Severe report deleted successfully');
    } catch (err) {
      console.error('Error deleting severe report:', err);
      setError('Failed to delete severe report');
    }
  };

  const formatTimestamp = (timestamp) => {
    if (!timestamp) return 'Unknown';
    try {
      const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
      return date.toLocaleString('en-GB', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        timeZone: 'Europe/London',
      });
    } catch {
      return 'Unknown';
    }
  };

  return (
    <div className="p-6 container mx-auto">
      <h1 className="text-3xl font-bold text-gray-800 mb-6">Admin Dashboard</h1>
      {error && <p className="text-red-500 mb-4 bg-red-100 p-3 rounded-lg">{error}</p>}
      <div className="flex flex-col md:flex-row gap-6">
        <div className="md:w-1/3 bg-white p-6 rounded-lg shadow-md">
          <h2 className="text-xl font-semibold text-gray-700 mb-4">Add Severe Weather Report</h2>
          <div className="mb-4">
            <label className="block text-gray-700 mb-2">Date</label>
            <input
              type="date"
              value={date}
              onChange={(e) => setDate(e.target.value)}
              className="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>
          <div className="mb-4">
            <label className="block text-gray-700 mb-2">Observed Time</label>
            <input
              type="time"
              value={observedTime}
              onChange={(e) => setObservedTime(e.target.value)}
              className="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>
          <div className="mb-4">
            <label className="block text-gray-700 mb-2">Condition</label>
            <select
              value={condition}
              onChange={(e) => setCondition(e.target.value)}
              className="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            >
              {['Rainfall', 'Hail', 'Tornado', 'Gusts'].map((c) => (
                <option key={c} value={c}>{c}</option>
              ))}
            </select>
          </div>
          <div className="mb-4">
            <label className="block text-gray-700 mb-2">Latitude</label>
            <input
              type="number"
              value={lat}
              onChange={(e) => setLat(e.target.value)}
              placeholder="Click map to select"
              className="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>
          <div className="mb-4">
            <label className="block text-gray-700 mb-2">Longitude</label>
            <input
              type="number"
              value={lon}
              onChange={(e) => setLon(e.target.value)}
              placeholder="Click map to select"
              className="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>
          <button
            onClick={addSevereReport}
            className="w-full bg-blue-600 text-white p-3 rounded-lg hover:bg-blue-700 transition"
          >
            Add Report
          </button>
          <h2 className="text-xl font-semibold text-gray-700 mt-6 mb-4">Severe Reports</h2>
          <ul className="space-y-2 max-h-60 overflow-y-auto">
            {severeReports.map((report) => (
              <li key={report.id} className="p-3 bg-gray-100 rounded-lg">
                {report.date} - {report.condition} at [{report.location[1].toFixed(4)}, {report.location[0].toFixed(4)}]
                <br />
                Created By: {report.createdBy || 'Unknown'}
                <br />
                Created: {formatTimestamp(report.createdAt)}
                <br />
                Observed: {report.observedAt ? new Date(report.observedAt).toLocaleString('en-GB', {
                  day: '2-digit',
                  month: '2-digit',
                  year: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit',
                  timeZone: 'Europe/London',
                }) : 'Unknown'}
                <button
                  onClick={() => deleteSevereReport(report.id)}
                  className="ml-2 text-red-500 hover:text-red-700"
                >
                  Delete
                </button>
              </li>
            ))}
          </ul>
        </div>
        <div className="md:w-2/3">
          <div id="admin-map" className="h-[500px] w-full rounded-lg shadow-md"></div>
        </div>
      </div>
    </div>
  );
};


const AddSevereReportPage = ({ user }) => {
  const [severeReports, setSevereReports] = useState([]);
  const [date, setDate] = useState('');
  const [observedTime, setObservedTime] = useState('');
  const [condition, setCondition] = useState('Rainfall');
  const [lat, setLat] = useState('');
  const [lon, setLon] = useState('');
  const [error, setError] = useState(null);
  const mapRef = useRef(null);
  const markerRef = useRef(null);

  useEffect(() => {
    waitForLeaflet(() => {
      try {
        const map = L.map('severe-report-map').setView([54.5, -3], 6);
        mapRef.current = map;
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 19,
          attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
        }).addTo(map).on('tileerror', error => {
          console.error('Tile error:', error);
          setError('Failed to load map tiles');
        });
        map.on('click', (e) => {
          setLat(e.latlng.lat.toFixed(4));
          setLon(e.latlng.lng.toFixed(4));
          if (markerRef.current) {
            map.removeLayer(markerRef.current);
          }
          markerRef.current = L.marker([e.latlng.lat, e.latlng.lng]).addTo(map);
        });
        setTimeout(() => {
          map.invalidateSize();
          console.log('Map size invalidated for AddSevereReportPage');
        }, 100);

        return () => {
          console.log('Cleaning up AddSevereReportPage map');
          map.remove();
        };
      } catch (err) {
        console.error('Error initializing AddSevereReportPage map:', err);
        setError('Failed to initialize map');
      }
    });

    db.collection('severe_reports')
      .where('createdBy', '==', user.uid)
      .get()
      .then((snapshot) => {
        const reports = snapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
          createdAt: doc.data().createdAt?.toDate ? doc.data().createdAt.toDate() : new Date(doc.data().createdAt),
          observedAt: doc.data().observedAt ? new Date(doc.data().observedAt) : null
        }));
        setSevereReports(reports);
      })
      .catch((err) => {
        console.error('Error fetching severe reports:', err);
        setError('Failed to load your severe reports');
      });
  }, [user]);

  const addSevereReport = async () => {
    if (!date || !observedTime || !lat || !lon || !condition) {
      setError('Please fill in all fields');
      return;
    }
    if (!user) {
      setError('You must be logged in to add a severe report');
      return;
    }
    try {
      const observedAt = new Date(`${date}T${observedTime}:00Z`).toISOString();
      const createdBy = user.uid;
      await db.collection('severe_reports').add({
        date,
        condition,
        location: [parseFloat(lon), parseFloat(lat)],
        createdBy,
        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
        observedAt
      });
      setSevereReports([
        ...severeReports,
        {
          date,
          condition,
          location: [parseFloat(lon), parseFloat(lat)],
          createdBy: user.email || user.displayName || user.uid,
          createdAt: new Date(),
          observedAt
        }
      ]);
      setDate('');
      setObservedTime('');
      setLat('');
      setLon('');
      setCondition('Rainfall');
      if (markerRef.current) {
        mapRef.current.removeLayer(markerRef.current);
        markerRef.current = null;
      }
      alert('Severe report added successfully');
    } catch (err) {
      console.error('Error adding severe report:', err);
      setError('Failed to add severe report');
    }
  };

  const deleteSevereReport = async (reportId) => {
    try {
      await db.collection('severe_reports').doc(reportId).delete();
      setSevereReports(severeReports.filter((r) => r.id !== reportId));
      alert('Severe report deleted successfully');
    } catch (err) {
      console.error('Error deleting severe report:', err);
      setError('Failed to delete severe report');
    }
  };

  const formatTimestamp = (timestamp) => {
    if (!timestamp) return 'Unknown';
    try {
      const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
      return date.toLocaleString('en-GB', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        timeZone: 'Europe/London'
      });
    } catch {
      return 'Unknown';
    }
  };

  return (
    <div className="p-6 container mx-auto">
      <h1 className="text-3xl font-bold text-gray-800 mb-6">Add Severe Weather Report</h1>
      {error && <p className="text-red-500 mb-4 bg-red-100 p-3 rounded-lg">{error}</p>}
      <div className="flex flex-col md:flex-row gap-6">
        <div className="md:w-1/3 bg-white p-6 rounded-lg shadow-md">
          <h2 className="text-xl font-semibold text-gray-700 mb-4">Submit Severe Weather Report</h2>
          <div className="mb-4">
            <label className="block text-gray-700 mb-2">Date</label>
            <input
              type="date"
              value={date}
              onChange={(e) => setDate(e.target.value)}
              className="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>
          <div className="mb-4">
            <label className="block text-gray-700 mb-2">Observed Time</label>
            <input
              type="time"
              value={observedTime}
              onChange={(e) => setObservedTime(e.target.value)}
              className="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>
          <div className="mb-4">
            <label className="block text-gray-700 mb-2">Condition</label>
            <select
              value={condition}
              onChange={(e) => setCondition(e.target.value)}
              className="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            >
              {['Rainfall', 'Hail', 'Tornado', 'Gusts'].map((c) => (
                <option key={c} value={c}>{c}</option>
              ))}
            </select>
          </div>
          <div className="mb-4">
            <label className="block text-gray-700 mb-2">Latitude</label>
            <input
              type="number"
              value={lat}
              onChange={(e) => setLat(e.target.value)}
              placeholder="Click map to select"
              className="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>
          <div className="mb-4">
            <label className="block text-gray-700 mb-2">Longitude</label>
            <input
              type="number"
              value={lon}
              onChange={(e) => setLon(e.target.value)}
              placeholder="Click map to select"
              className="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>
          <button
            onClick={addSevereReport}
            className="w-full bg-blue-600 text-white p-3 rounded-lg hover:bg-blue-700 transition"
          >
            Submit Report
          </button>
          <h2 className="text-xl font-semibold text-gray-700 mt-6 mb-4">Your Severe Reports</h2>
          <ul className="space-y-2 max-h-60 overflow-y-auto">
            {severeReports.map((report) => (
              <li key={report.id} className="p-3 bg-gray-100 rounded-lg">
                {report.date} - {report.condition} at [{report.location[1].toFixed(4)}, {report.location[0].toFixed(4)}]
                <br />
                Created: {formatTimestamp(report.createdAt)}
                <br />
                Observed: {report.observedAt ? new Date(report.observedAt).toLocaleString('en-GB', {
                  day: '2-digit',
                  month: '2-digit',
                  year: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit',
                  timeZone: 'Europe/London'
                }) : 'Unknown'}
                <button
                  onClick={() => deleteSevereReport(report.id)}
                  className="ml-2 text-red-500 hover:text-red-700"
                >
                  Delete
                </button>
              </li>
            ))}
          </ul>
        </div>
        <div className="md:w-2/3">
          <div id="severe-report-map" className="h-[500px] w-full rounded-lg shadow-md"></div>
        </div>
      </div>
    </div>
  );
};
const LeaderboardPage = () => {
  const [users, setUsers] = useState([]);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchLeaderboard = async () => {
      try {
        const outlooksSnapshot = await db.collection('outlooks').get();
        const outlooks = outlooksSnapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        }));

        const userScores = {};
        outlooks.forEach(outlook => {
          if (outlook.username && outlook.score != null) {
            if (!userScores[outlook.username]) {
              userScores[outlook.username] = { totalScore: 0, count: 0 };
            }
            userScores[outlook.username].totalScore += outlook.score;
            userScores[outlook.username].count += 1;
          }
        });

        const leaderboard = Object.entries(userScores)
          .map(([username, { totalScore, count }]) => ({
            username,
            averageScore: count > 0 ? totalScore / count : 0,
            forecasts: count
          }))
          .sort((a, b) => b.averageScore - a.averageScore)
          .slice(0, 10);

        setUsers(leaderboard);
      } catch (err) {
        console.error('Error fetching leaderboard:', err);
        setError('Failed to load leaderboard');
      }
    };
    fetchLeaderboard();
  }, []);

  return (
    <div className="p-6 container mx-auto">
      <h1 className="text-3xl font-bold text-gray-800 mb-6">Leaderboard</h1>
      {error && <p className="text-red-500 mb-4 bg-red-100 p-3 rounded-lg">{error}</p>}
      <div className="bg-white p-6 rounded-lg shadow-md">
        <h2 className="text-xl font-semibold text-gray-700 mb-4">Top Forecasters</h2>
        <ul className="space-y-2 max-h-96 overflow-y-auto">
          {users.map((user, index) => (
            <li key={user.username} className="p-3 bg-gray-100 rounded-lg">
              <span className="font-semibold">{index + 1}. {user.username}</span>
              <br />
              Average Score: {user.averageScore.toFixed(2)} | Forecasts: {user.forecasts}
            </li>
          ))}
        </ul>
      </div>
    </div>
  );
};
    const ArchivePage = () => {
  const [outlooks, setOutlooks] = useState([]);
  const [filteredOutlooks, setFilteredOutlooks] = useState([]);
  const [selectedOutlook, setSelectedOutlook] = useState(null);
  const [error, setError] = useState(null);
  const [dateFilter, setDateFilter] = useState('');
  const [searchUsername, setSearchUsername] = useState('');
  const [sortBy, setSortBy] = useState('latest');
  const [lightningStrikes, setLightningStrikes] = useState([]);
  const [severeReports, setSevereReports] = useState([]);
  const [showLightning, setShowLightning] = useState(true);
  const [showSevereReports, setShowSevereReports] = useState(true);
  const mapRef = useRef(null);
  const geoJsonLayersRef = useRef([]);
  const lightningLayerRef = useRef(null);
  const severeLayerRef = useRef(null);

  const calculateAndUpdateScore = async (outlook) => {
    if (!outlook.username || !outlook.date || !outlook.polygons) {
      console.warn('Skipping score calculation for invalid outlook:', outlook.id, outlook);
      return;
    }
    if (outlook.score != null) {
      console.log('Score already calculated for outlook:', outlook.id);
      return;
    }
    const endTime = new Date(outlook.date);
    endTime.setDate(endTime.getDate() + 1);
    endTime.setHours(5, 59, 59, 999);
    const currentTime = new Date();
    if (currentTime < endTime) {
      console.log('Outlook period not yet ended:', outlook.id, endTime);
      return;
    }
    try {
      const parsedPolygons = outlook.polygons
        .map(p => {
          try {
            return {
              ...p,
              geometry: {
                ...p.geometry,
                coordinates: JSON.parse(p.geometry.coordinates),
              },
              properties: {
                ...p.properties,
                Name: p.properties.Name || 'low risk',
                color: p.properties.color || RISK_COLORS[p.properties.Name?.toLowerCase() || 'low risk'],
              },
            };
          } catch (err) {
            console.error('Error parsing polygon for outlook:', outlook.id, err);
            return null;
          }
        })
        .filter(p => p !== null);
      console.log('Parsed polygons for scoring:', parsedPolygons.length);
      if (parsedPolygons.length === 0) {
        console.error('No valid polygons for outlook:', outlook.id);
        return;
      }
      const score = await calculateScore(parsedPolygons, outlook.date, outlook.id);
      setOutlooks(prev => prev.map(o => (o.id === outlook.id ? { ...o, score } : o)));
      setFilteredOutlooks(prev => prev.map(o => (o.id === outlook.id ? { ...o, score } : o)));
    } catch (err) {
      console.error('Error calculating score for outlook:', outlook.id, err);
    }
  };

  // Initialize the Leaflet map
  useEffect(() => {
    waitForLeaflet(() => {
      try {
        const map = L.map('archive-map').setView([54.5, -3], 6);
        mapRef.current = map;
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 19,
          attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
        }).addTo(map).on('tileerror', error => {
          console.error('Tile error:', error);
          setError('Failed to load map tiles');
        });

        setTimeout(() => {
          map.invalidateSize();
          console.log('Map size invalidated for ArchivePage');
        }, 100);

        return () => {
          console.log('Cleaning up ArchivePage map');
          map.remove();
        };
      } catch (err) {
        console.error('Error initializing ArchivePage map:', err);
        setError('Failed to initialize map');
      }
    });
  }, []);

  useEffect(() => {
    const fetchOutlooks = async () => {
      try {
        const snapshot = await db.collection('outlooks').get();
        const outlooksData = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data(),
          createdAt: doc.data().createdAt?.toDate ? doc.data().createdAt.toDate() : new Date(doc.data().createdAt),
        }));
        console.log('Fetched outlooks:', outlooksData);
        setOutlooks(outlooksData);
        setFilteredOutlooks(outlooksData);
        outlooksData.forEach(outlook => calculateAndUpdateScore(outlook));
      } catch (err) {
        console.error('Error fetching outlooks:', err);
        setError('Failed to load archived outlooks');
      }
    };
    fetchOutlooks();
  }, []);

  useEffect(() => {
    let filtered = outlooks;
    if (dateFilter) {
      filtered = filtered.filter(outlook => outlook.date === dateFilter);
    }
    if (searchUsername) {
      filtered = filtered.filter(outlook => outlook.username.toLowerCase().includes(searchUsername.toLowerCase()));
    }
    filtered = filtered.sort((a, b) => {
      if (sortBy === 'latest') {
        return b.createdAt - a.createdAt;
      } else if (sortBy === 'mostLikes') {
        return (b.likes?.length || 0) - (a.likes?.length || 0);
      } else if (sortBy === 'bestScore') {
        return (b.score || 0) - (a.score || 0);
      }
      return 0;
    });
    setFilteredOutlooks(filtered);
  }, [dateFilter, searchUsername, sortBy, outlooks]);

  useEffect(() => {
    if (!mapRef.current || !selectedOutlook) return;
    geoJsonLayersRef.current.forEach(layer => {
      if (mapRef.current.hasLayer(layer)) {
        mapRef.current.removeLayer(layer);
      }
    });
    geoJsonLayersRef.current = [];
    if (selectedOutlook.polygons) {
      const parsedPolygons = selectedOutlook.polygons
        .map(p => {
          try {
            return {
              ...p,
              geometry: {
                ...p.geometry,
                coordinates: JSON.parse(p.geometry.coordinates),
              },
              properties: {
                ...p.properties,
                Name: p.properties.Name || 'low risk',
                color: p.properties.color || RISK_COLORS[p.properties.Name?.toLowerCase() || 'low risk'],
              },
            };
          } catch (err) {
            console.error('Error parsing polygon:', p, err);
            return null;
          }
        })
        .filter(p => p !== null);

      const polygonsByRisk = RISK_ORDER.reduce((acc, risk) => {
        acc[risk] = parsedPolygons.filter(p => p.properties.Name?.toLowerCase() === risk);
        return acc;
      }, {});

      RISK_ORDER.forEach(risk => {
        if (polygonsByRisk[risk].length) {
          const layer = L.geoJSON(polygonsByRisk[risk], {
            style: feature => ({
              color: feature.properties.color,
              fillColor: feature.properties.Name.toLowerCase() === 'severe risk' ? 'transparent' : feature.properties.color,
              fillOpacity: feature.properties.Name.toLowerCase() === 'severe risk' ? 0 : 0.4,
              weight: 2,
            }),
          }).addTo(mapRef.current);
          geoJsonLayersRef.current.push(layer);
        }
      });

      fetchLightningData(selectedOutlook.date, setError).then(strikes => {
        setLightningStrikes(strikes);
        const lightningFeatures = strikes.map(s => ({
          type: 'Feature',
          geometry: {
            type: 'Point',
            coordinates: s.coordinates,
          },
        }));
        if (lightningLayerRef.current) {
          mapRef.current.removeLayer(lightningLayerRef.current);
        }
        lightningLayerRef.current = L.geoJSON(lightningFeatures, {
          pointToLayer: (feature, latlng) => L.circleMarker(latlng, {
            radius: 5,
            color: '#ff0',
            fillOpacity: 0.8,
          }),
        });
        if (showLightning) {
          lightningLayerRef.current.addTo(mapRef.current);
        }
      });

      db.collection('severe_reports')
        .where('date', '==', selectedOutlook.date)
        .get()
        .then(snapshot => {
          const reports = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data(),
            createdAt: doc.data().createdAt?.toDate ? doc.data().createdAt.toDate() : new Date(doc.data().createdAt),
            observedAt: doc.data().observedAt ? new Date(doc.data().observedAt) : null,
          }));
          setSevereReports(reports);
          const severeFeatures = reports
            .filter(r => r.location && r.location.length === 2)
            .map(r => ({
              type: 'Feature',
              geometry: {
                type: 'Point',
                coordinates: r.location,
              },
              properties: {
                condition: r.condition,
                createdBy: r.createdBy,
                createdAt: r.createdAt,
                observedAt: r.observedAt,
              },
            }));
          if (severeLayerRef.current) {
            mapRef.current.removeLayer(severeLayerRef.current);
          }
          severeLayerRef.current = L.geoJSON(severeFeatures, {
            pointToLayer: (feature, latlng) => L.circleMarker(latlng, {
              radius: 5,
              color: '#f00',
              fillOpacity: 0.8,
            }).bindPopup(`
              <b>Condition:</b> ${feature.properties.condition}<br/>
              <b>Created By:</b> ${feature.properties.createdBy || 'Unknown'}<br/>
              <b>Created:</b> ${feature.properties.createdAt ? feature.properties.createdAt.toLocaleString('en-GB') : 'Unknown'}<br/>
              <b>Observed:</b> ${feature.properties.observedAt ? feature.properties.observedAt.toLocaleString('en-GB') : 'Unknown'}
            `),
          });
          if (showSevereReports) {
            severeLayerRef.current.addTo(mapRef.current);
          }
        })
        .catch(err => {
          console.error('Error fetching severe reports:', err);
          setError('Failed to load severe reports');
        });

      setTimeout(() => {
        if (mapRef.current) {
          mapRef.current.invalidateSize();
        }
      }, 100);
    }
  }, [selectedOutlook]);

  useEffect(() => {
    if (mapRef.current && lightningLayerRef.current) {
      if (showLightning) {
        lightningLayerRef.current.addTo(mapRef.current);
      } else {
        mapRef.current.removeLayer(lightningLayerRef.current);
      }
    }
  }, [showLightning]);

  useEffect(() => {
    if (mapRef.current && severeLayerRef.current) {
      if (showSevereReports) {
        severeLayerRef.current.addTo(mapRef.current);
      } else {
        mapRef.current.removeLayer(severeLayerRef.current);
      }
    }
  }, [showSevereReports]);

  const formatTimestamp = (timestamp) => {
    if (!timestamp) return 'Unknown';
    try {
      const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
      return date.toLocaleString('en-GB', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        timeZone: 'Europe/London',
      });
    } catch {
      return 'Unknown';
    }
  };

  return (
    <div className="p-6 container mx-auto">
      <h1 className="text-3xl font-bold text-gray-800 mb-6">Archive</h1>
      {error && <p className="text-red-500 mb-4 bg-red-100 p-3 rounded-lg">{error}</p>}
      <div className="flex flex-col md:flex-row gap-6">
        <div className="md:w-1/3 bg-white p-6 rounded-lg shadow-md">
          <div className="mb-4">
            <label className="block text-gray-700 mb-2">Filter by Date</label>
            <input
              type="date"
              value={dateFilter}
              onChange={e => setDateFilter(e.target.value)}
              className="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>
          <div className="mb-4">
            <label className="block text-gray-700 mb-2">Search by Username</label>
            <input
              type="text"
              value={searchUsername}
              onChange={e => setSearchUsername(e.target.value)}
              placeholder="Enter username"
              className="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>
          <div className="mb-4">
            <label className="block text-gray-700 mb-2">Sort By</label>
            <select
              value={sortBy}
              onChange={e => setSortBy(e.target.value)}
              className="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            >
              <option value="latest">Latest Published</option>
              <option value="mostLikes">Most Likes</option>
              <option value="bestScore">Best Score</option>
            </select>
          </div>
          <div className="mb-4">
            <button
              onClick={() => setShowLightning(!showLightning)}
              className="bg-yellow-500 text-white p-2 rounded-lg hover:bg-yellow-600 transition mr-2"
            >
              {showLightning ? 'Hide Lightning' : 'Show Lightning'}
            </button>
            <button
              onClick={() => setShowSevereReports(!showSevereReports)}
              className="bg-red-500 text-white p-2 rounded-lg hover:bg-red-600 transition"
            >
              {showSevereReports ? 'Hide Severe Reports' : 'Show Severe Reports'}
            </button>
          </div>
          <ul className="space-y-2 max-h-60 overflow-y-auto">
            {filteredOutlooks.map(outlook => (
              <li
                key={outlook.id}
                onClick={() => setSelectedOutlook(outlook)}
                className="cursor-pointer p-3 hover:bg-gray-100 rounded-lg"
              >
                {outlook.username} - {outlook.date} {outlook.version} (Score: {outlook.score != null ? outlook.score.toFixed(2) : 'Pending'})
                <br />
                Published: {formatTimestamp(outlook.createdAt)}
              </li>
            ))}
          </ul>
        </div>
        <div className="md:w-2/3">
          <div id="archive-map" className="h-[700px] w-full rounded-lg shadow-md"></div>
        </div>
      </div>
    </div>
  );
};

    const getNextVersion = async (collection, email, date) => {
      try {
        const snapshot = await db.collection(collection)
          .where('email', '==', email)
          .where('date', '==', date)
          .get();
        const count = snapshot.size;
        return `version ${count + 1}`;
      } catch (err) {
        console.error(`Error fetching version count for ${collection}:`, err);
        return 'version 1';
      }
    };

    const App = () => {
      const [user, setUser] = useState(null);
      const [username, setUsername] = useState(null);
      const [email, setEmail] = useState(null);
      const history = useHistory();

      useEffect(() => {
        const unsubscribe = auth.onAuthStateChanged(async user => {
          if (user) {
            setUser(user);
            setEmail(user.email);
            try {
              const userDoc = await db.collection('users').doc(user.uid).get();
              if (userDoc.exists) {
                setUsername(userDoc.data().username);
              } else {
                const defaultUsername = user.email.split('@')[0];
                await db.collection('users').doc(user.uid).set({
                  username: defaultUsername,
                  email: user.email,
                  createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                setUsername(defaultUsername);
              }
            } catch (err) {
              console.error('Error fetching/setting user data:', err);
            }
          } else {
            setUser(null);
            setUsername(null);
            setEmail(null);
          }
        });
        return () => unsubscribe();
      }, []);

      return (
        <div className="min-h-screen bg-gray-50">
          <NavBar user={user} username={username} />
          <Switch>
            <Route exact path="/" component={WelcomePage} />
            <Route path="/create">
              {user ? <CreateOutlookPage user={user} username={username} email={email} /> : <Redirect to="/account" />}
            </Route>
            <Route path="/view" render={() => <ViewOutlookPage user={user} />} />
            <Route path="/your-uploads">
              {user ? <YourUploadsPage user={user} username={username} email={email} /> : <Redirect to="/account" />}
            </Route>
            <Route path="/archive" component={ArchivePage} />
            <Route path="/account">
              {!user ? <AccountPage /> : <Redirect to="/" />}
            </Route>
            <Route path="/admin">
              {user && user.email === 'admin@example.com' ? <AdminPage /> : <Redirect to="/" />}
            </Route>
            <Route path="/add-severe-report">
              {user ? <AddSevereReportPage user={user} /> : <Redirect to="/account" />}
            </Route>
            <Route path="/leaderboard" component={LeaderboardPage} />
          </Switch>
        </div>
      );
    };

    const root = createRoot(document.getElementById('root'));
    root.render(
      <BrowserRouter>
        <App />
      </BrowserRouter>
    );
  </script>
</html>
